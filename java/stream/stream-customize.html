

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Custom stream processing &#8212; Akka Documentation</title>
    
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '@version@',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="../../_static/toc.js"></script>
    <script type="text/javascript" src="../../_static/prettify.js"></script>
    <script type="text/javascript" src="../../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../../_static/effects.core.js"></script>
    <script type="text/javascript" src="../../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../../_static/ga.js"></script>
    <script type="text/javascript" src="../../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../../index.html" />
    <link rel="up" title="Streams" href="index.html" />
    <link rel="next" title="Integration" href="stream-integrations.html" />
    <link rel="prev" title="Dynamic stream handling" href="stream-dynamic.html" />


  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Custom stream processing</div>
      <div class="pdf-link"><a href="../../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../../AkkaJava.pdf" title="Akka Java Documentation"><img src="../../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="stream-integrations.html">Integration</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../../java.html">Java Contents</a> <span class="divider">|</span> <a href="../../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="stream-dynamic.html">Dynamic stream handling</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version @version@
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="custom-stream-processing">
<span id="stream-customize-java"></span><h1>Custom stream processing</h1>
<p>While the processing vocabulary of Akka Streams is quite rich (see the <a class="reference internal" href="stream-cookbook.html#stream-cookbook-java"><span class="std std-ref">Streams Cookbook</span></a> for examples) it
is sometimes necessary to define new transformation stages either because some functionality is missing from the
stock operations, or for performance reasons. In this part we show how to build custom processing stages and graph
junctions of various kinds.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">A custom graph stage should not be the first tool you reach for, defining graphs using flows
and the graph DSL is in general easier and does to a larger extent protect you from mistakes that
might be easy to make with a custom <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code></p>
</div>
<div class="section" id="custom-processing-with-graphstage">
<span id="graphstage-java"></span><h2>Custom processing with GraphStage</h2>
<p>The <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> abstraction can be used to create arbitrary graph processing stages with any number of input
or output ports. It is a counterpart of the <code class="docutils literal"><span class="pre">GraphDSL.create()</span></code> method which creates new stream processing
stages by composing  others. Where <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> differs is that it creates a stage that is itself not divisible into
smaller ones, and allows state to be maintained inside it in a safe way.</p>
<p>As a first motivating example, we will build a new <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> that will simply emit numbers from 1 until it is
cancelled. To start, we need to define the &quot;interface&quot; of our stage, which is called <em>shape</em> in Akka Streams terminology
(this is explained in more detail in the section <a class="reference internal" href="stream-composition.html#composition-java"><span class="std std-ref">Modularity, Composition and Hierarchy</span></a>).</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">NumbersSource</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="c1">// Define the (sole) output port of this stage</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;NumbersSource.out&quot;</span><span class="o">);</span>

  <span class="c1">// Define the shape of this stage, which is SourceShape with the port we defined above</span>
  <span class="k">private</span> <span class="k">final</span> <span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">SourceShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// This is where the actual (possibly stateful) logic is created</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">())</span> <span class="o">{</span>
      <span class="c1">// All state MUST be inside the GraphStageLogic,</span>
      <span class="c1">// never inside the enclosing GraphStage.</span>
      <span class="c1">// This state is safe to access and modify from all the</span>
      <span class="c1">// callbacks that are provided by GraphStageLogic and the</span>
      <span class="c1">// registered handlers.</span>
      <span class="k">private</span> <span class="n">int</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">counter</span><span class="o">);</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

    <span class="o">};</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>As you see, in itself the <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> only defines the ports of this stage and a shape that contains the ports.
It also has a user implemented method called <code class="docutils literal"><span class="pre">createLogic</span></code>. If you recall, stages are reusable in multiple
materializations, each resulting in a different executing entity. In the case of <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> the actual running
logic is modeled as an instance of a <code class="xref py py-class docutils literal"><span class="pre">GraphStageLogic</span></code> which will be created by the materializer by calling
the <code class="docutils literal"><span class="pre">createLogic</span></code> method. In other words, all we need to do is to create a suitable logic that will emit the
numbers we want.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">It is very important to keep the GraphStage object itself immutable and reusable. All mutable state needs to be
confined to the GraphStageLogic that is created for every materialization.</p>
</div>
<p>In order to emit from a <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> in a backpressured stream one needs first to have demand from downstream.
To receive the necessary events one needs to register a subclass of <code class="xref py py-class docutils literal"><span class="pre">AbstractOutHandler</span></code> with the output port
(<code class="xref py py-class docutils literal"><span class="pre">Outlet</span></code>). This handler will receive events related to the lifecycle of the port. In our case we need to
override <code class="docutils literal"><span class="pre">onPull()</span></code> which indicates that we are free to emit a single element. There is another callback,
<code class="docutils literal"><span class="pre">onDownstreamFinish()</span></code> which is called if the downstream cancelled. Since the default behavior of that callback is
to stop the stage, we don't need to override it. In the <code class="docutils literal"><span class="pre">onPull</span></code> callback we simply emit the next number.</p>
<p>Instances of the above <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> are subclasses of <code class="docutils literal"><span class="pre">Graph&lt;SourceShape&lt;Int&gt;,Unit&gt;</span></code> which means
that they are already usable in many situations, but do not provide the DSL methods we usually have for other
<code class="xref py py-class docutils literal"><span class="pre">Source</span></code> s. In order to convert this <code class="xref py py-class docutils literal"><span class="pre">Graph</span></code> to a proper <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> we need to wrap it using
<code class="docutils literal"><span class="pre">Source.fromGraph</span></code> (see <a class="reference internal" href="stream-composition.html#composition-java"><span class="std std-ref">Modularity, Composition and Hierarchy</span></a> for more details about graphs and DSLs). Now we can use the
source as any other built-in one:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// A GraphStage is a proper Graph, just like what GraphDSL.create would return</span>
<span class="nc">Graph</span><span class="o">&lt;</span><span class="nc">SourceShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">sourceGraph</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NumbersSource</span><span class="o">();</span>

<span class="c1">// Create a Source from the Graph to access the DSL</span>
<span class="nc">Source</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">NotUsed</span><span class="o">&gt;</span> <span class="n">mySource</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromGraph</span><span class="o">(</span><span class="n">sourceGraph</span><span class="o">);</span>

<span class="c1">// Returns 55</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">mySource</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">runFold</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">next</span><span class="o">,</span> <span class="n">mat</span><span class="o">);</span>

<span class="c1">// The source is reusable. This returns 5050</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result2</span> <span class="k">=</span> <span class="n">mySource</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">100</span><span class="o">).</span><span class="n">runFold</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">next</span><span class="o">,</span> <span class="n">mat</span><span class="o">);</span>
</pre></div>
</div>
<p>Similarly, to create a custom <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code> one can register a subclass <code class="xref py py-class docutils literal"><span class="pre">InHandler</span></code> with the stage <code class="xref py py-class docutils literal"><span class="pre">Inlet</span></code>.
The <code class="docutils literal"><span class="pre">onPush()</span></code> callback is used to signal the handler a new element has been pushed to the stage,
and can hence be grabbed and used. <code class="docutils literal"><span class="pre">onPush()</span></code> can be overridden to provide custom behaviour.
Please note, most Sinks would need to request upstream elements as soon as they are created: this can be
done by calling <code class="docutils literal"><span class="pre">pull(inlet)</span></code> in the <code class="docutils literal"><span class="pre">preStart()</span></code> callback.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">StdoutSink</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">SinkShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;StdoutSink.in&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">SinkShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">SinkShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">SinkShape</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">())</span> <span class="o">{</span>

      <span class="c1">// This requests one element at the Sink startup.</span>
      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="nc">Integer</span> <span class="n">element</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="port-states-abstractinhandler-and-abstractouthandler">
<h3>Port states, AbstractInHandler and AbstractOutHandler</h3>
<p>In order to interact with a port (<code class="xref py py-class docutils literal"><span class="pre">Inlet</span></code> or <code class="xref py py-class docutils literal"><span class="pre">Outlet</span></code>) of the stage we need to be able to receive events
and generate new events belonging to the port. From the <code class="xref py py-class docutils literal"><span class="pre">GraphStageLogic</span></code> the following operations are available
on an output port:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">push(out,elem)</span></code> pushes an element to the output port. Only possible after the port has been pulled by downstream.</li>
<li><code class="docutils literal"><span class="pre">complete(out)</span></code> closes the output port normally.</li>
<li><code class="docutils literal"><span class="pre">fail(out,exception)</span></code> closes the port with a failure signal.</li>
</ul>
<p>The events corresponding to an <em>output</em> port can be received in an <code class="xref py py-class docutils literal"><span class="pre">AbstractOutHandler</span></code> instance registered to the
output port using <code class="docutils literal"><span class="pre">setHandler(out,handler)</span></code>. This handler has two callbacks:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">onPull()</span></code> is called when the output port is ready to emit the next element, <code class="docutils literal"><span class="pre">push(out,</span> <span class="pre">elem)</span></code> is now allowed
to be called on this port.</li>
<li><code class="docutils literal"><span class="pre">onDownstreamFinish()</span></code> is called once the downstream has cancelled and no longer allows messages to be pushed to it.
No more <code class="docutils literal"><span class="pre">onPull()</span></code> will arrive after this event. If not overridden this will default to stopping the stage.</li>
</ul>
<p>Also, there are two query methods available for output ports:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">isAvailable(out)</span></code> returns true if the port can be pushed.</li>
<li><code class="docutils literal"><span class="pre">isClosed(out)</span></code> returns true if the port is closed. At this point the port can not be pushed and will not be pulled anymore.</li>
</ul>
<p>The relationship of the above operations, events and queries are summarized in the state machine below. Green shows
the initial state while orange indicates the end state. If an operation is not listed for a state, then it is invalid
to call it while the port is in that state. If an event is not listed for a state, then that event cannot happen
in that state.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="../../_images/outport_transitions.png" class="align-center" src="../../_images/outport_transitions.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The following operations are available for <em>input</em> ports:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">pull(in)</span></code> requests a new element from an input port. This is only possible after the port has been pushed by upstream.</li>
<li><code class="docutils literal"><span class="pre">grab(in)</span></code> acquires the element that has been received during an <code class="docutils literal"><span class="pre">onPush()</span></code>. It cannot be called again until the
port is pushed again by the upstream.</li>
<li><code class="docutils literal"><span class="pre">cancel(in)</span></code> closes the input port.</li>
</ul>
<p>The events corresponding to an <em>input</em> port can be received in an <code class="xref py py-class docutils literal"><span class="pre">AbstractInHandler</span></code> instance registered to the
input port using <code class="docutils literal"><span class="pre">setHandler(in,</span> <span class="pre">handler)</span></code>. This handler has three callbacks:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">onPush()</span></code> is called when the input port has now a new element. Now it is possible to acquire this element using
<code class="docutils literal"><span class="pre">grab(in)</span></code> and/or call <code class="docutils literal"><span class="pre">pull(in)</span></code> on the port to request the next element. It is not mandatory to grab the
element, but if it is pulled while the element has not been grabbed it will drop the buffered element.</li>
<li><code class="docutils literal"><span class="pre">onUpstreamFinish()</span></code> is called once the upstream has completed and no longer can be pulled for new elements.
No more <code class="docutils literal"><span class="pre">onPush()</span></code> will arrive after this event. If not overridden this will default to stopping the stage.</li>
<li><code class="docutils literal"><span class="pre">onUpstreamFailure()</span></code> is called if the upstream failed with an exception and no longer can be pulled for new elements.
No more <code class="docutils literal"><span class="pre">onPush()</span></code> will arrive after this event. If not overridden this will default to failing the stage.</li>
</ul>
<p>Also, there are three query methods available for input ports:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">isAvailable(in)</span></code> returns true if a data element can be grabbed from the port</li>
<li><code class="docutils literal"><span class="pre">hasBeenPulled(in)</span></code> returns true if the port has been already pulled. Calling <code class="docutils literal"><span class="pre">pull(in)</span></code> in this state is illegal.</li>
<li><code class="docutils literal"><span class="pre">isClosed(in)</span></code> returns true if the port is closed. At this point the port can not be pulled and will not be pushed anymore.</li>
</ul>
<p>The relationship of the above operations, events and queries are summarized in the state machine below. Green shows
the initial state while orange indicates the end state. If an operation is not listed for a state, then it is invalid
to call it while the port is in that state. If an event is not listed for a state, then that event cannot happen
in that state.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="../../_images/inport_transitions.png" class="align-center" src="../../_images/inport_transitions.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Finally, there are two methods available for convenience to complete the stage and all of its ports:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">completeStage()</span></code> is equivalent to closing all output ports and cancelling all input ports.</li>
<li><code class="docutils literal"><span class="pre">failStage(exception)</span></code> is equivalent to failing all output ports and cancelling all input ports.</li>
</ul>
<p>In some cases it is inconvenient and error prone to react on the regular state machine events with the
signal based API described above. For those cases there is an API which allows for a more declarative sequencing
of actions which will greatly simplify some use cases at the cost of some extra allocations. The difference
between the two APIs could be described as that the first one is signal driven from the outside, while this API
is more active and drives its surroundings.</p>
<p>The operations of this part of the :class:<code class="docutils literal"><span class="pre">GraphStage</span></code> API are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">emit(out,</span> <span class="pre">elem)</span></code> and <code class="docutils literal"><span class="pre">emitMultiple(out,</span> <span class="pre">Iterable(elem1,</span> <span class="pre">elem2))</span></code> replaces the <code class="docutils literal"><span class="pre">OutHandler</span></code> with a handler that emits
one or more elements when there is demand, and then reinstalls the current handlers</li>
<li><code class="docutils literal"><span class="pre">read(in)(andThen)</span></code> and <code class="docutils literal"><span class="pre">readN(in,</span> <span class="pre">n)(andThen)</span></code> replaces the <code class="docutils literal"><span class="pre">InHandler</span></code> with a handler that reads one or
more elements as they are pushed and allows the handler to react once the requested number of elements has been read.</li>
<li><code class="docutils literal"><span class="pre">abortEmitting()</span></code> and <code class="docutils literal"><span class="pre">abortReading()</span></code> which will cancel an ongoing emit or read</li>
</ul>
<p>Note that since the above methods are implemented by temporarily replacing the handlers of the stage you should never
call <code class="docutils literal"><span class="pre">setHandler</span></code> while they are running <code class="docutils literal"><span class="pre">emit</span></code> or <code class="docutils literal"><span class="pre">read</span></code> as that interferes with how they are implemented.
The following methods are safe to call after invoking <code class="docutils literal"><span class="pre">emit</span></code> and <code class="docutils literal"><span class="pre">read</span></code> (and will lead to actually running the
operation when those are done): <code class="docutils literal"><span class="pre">complete(out)</span></code>, <code class="docutils literal"><span class="pre">completeStage()</span></code>, <code class="docutils literal"><span class="pre">emit</span></code>, <code class="docutils literal"><span class="pre">emitMultiple</span></code>, <code class="docutils literal"><span class="pre">abortEmitting()</span></code>
and <code class="docutils literal"><span class="pre">abortReading()</span></code></p>
<p>An example of how this API simplifies a stage can be found below in the second version of the :class:<code class="docutils literal"><span class="pre">Duplicator</span></code>.</p>
</div>
<div class="section" id="custom-linear-processing-stages-using-graphstage">
<h3>Custom linear processing stages using GraphStage</h3>
<p>Graph stages allows for custom linear processing stages through letting them
have one input and one output and using <code class="xref py py-class docutils literal"><span class="pre">FlowShape</span></code> as their shape.</p>
<p>Such a stage can be illustrated as a box with two flows as it is
seen in the illustration below. Demand flowing upstream leading to elements
flowing downstream.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_conceptual.png"><img alt="../../_images/graph_stage_conceptual.png" class="align-center" src="../../_images/graph_stage_conceptual.png" style="width: 500px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>To illustrate these concepts we create a small <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> that implements the <code class="docutils literal"><span class="pre">map</span></code> transformation.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_map.png"><img alt="../../_images/graph_stage_map.png" class="align-center" src="../../_images/graph_stage_map.png" style="width: 300px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Map calls <code class="docutils literal"><span class="pre">push(out)</span></code> from the <code class="docutils literal"><span class="pre">onPush()</span></code> handler and it also calls <code class="docutils literal"><span class="pre">pull()</span></code> from the <code class="docutils literal"><span class="pre">onPull</span></code> handler resulting in the
conceptual wiring above, and fully expressed in code below:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Map</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">f</span> <span class="k">=</span> <span class="n">f</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Map.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Map.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">)));</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Map is a typical example of a one-to-one transformation of a stream where
demand is passed along upstream elements passed on downstream.</p>
<p>To demonstrate a many-to-one stage we will implement
filter. The conceptual wiring of <code class="docutils literal"><span class="pre">Filter</span></code> looks like this:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_filter.png"><img alt="../../_images/graph_stage_filter.png" class="align-center" src="../../_images/graph_stage_filter.png" style="width: 300px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>As we see above, if the given predicate matches the current element we are propagating it downwards, otherwise
we return the “ball” to our upstream so that we get the new element. This is achieved by modifying the map
example by adding a conditional in the <code class="docutils literal"><span class="pre">onPush</span></code> handler and decide between a <code class="docutils literal"><span class="pre">pull(in)</span></code> or <code class="docutils literal"><span class="pre">push(out)</span></code> call
(and of course not having a mapping <code class="docutils literal"><span class="pre">f</span></code> function).</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">Filter</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">Filter</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">p</span> <span class="k">=</span> <span class="n">p</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Filter.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Filter.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">{</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">test</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="o">{</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">elem</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To complete the picture we define a one-to-many transformation as the next step. We chose a straightforward example stage
that emits every upstream element twice downstream. The conceptual wiring of this stage looks like this:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_duplicate.png"><img alt="../../_images/graph_stage_duplicate.png" class="align-center" src="../../_images/graph_stage_duplicate.png" style="width: 300px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This is a stage that has state: an option with the last element it has seen indicating if it
has duplicated this last element already or not. We must also make sure to emit the extra element
if the upstream completes.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Duplicator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Duplicator.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Duplicator.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Again: note that all mutable state</span>
      <span class="c1">// MUST be inside the GraphStageLogic</span>
      <span class="nc">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">lastElem</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">.</span><span class="n">none</span><span class="o">();</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">lastElem</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">.</span><span class="n">some</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">elem</span><span class="o">);</span>
          <span class="o">}</span>

          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onUpstreamFinish</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastElem</span><span class="o">.</span><span class="n">isDefined</span><span class="o">())</span> <span class="o">{</span>
              <span class="n">emit</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">lastElem</span><span class="o">.</span><span class="n">get</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">complete</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>


        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastElem</span><span class="o">.</span><span class="n">isDefined</span><span class="o">())</span> <span class="o">{</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">lastElem</span><span class="o">.</span><span class="n">get</span><span class="o">());</span>
              <span class="n">lastElem</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">.</span><span class="n">none</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this case a pull from downstream might be consumed by the stage itself rather
than passed along upstream as the stage might contain an element it wants to
push. Note that we also need to handle the case where the upstream closes while
the stage still has elements it wants to push downstream. This is done by
overriding <cite>onUpstreamFinish</cite> in the <cite>AbstractInHandler</cite> and provide custom logic
that should happen when the upstream has been finished.</p>
<p>This example can be simplified by replacing the usage of a mutable state with calls to
<code class="docutils literal"><span class="pre">emitMultiple</span></code> which will replace the handlers, emit each of multiple elements and then
reinstate the original handlers:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Duplicator2</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Duplicator.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;Duplicator.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="c1">// this will temporarily suspend this handler until the two elems</span>
            <span class="c1">// are emitted and then reinstates it</span>
            <span class="n">emitMultiple</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">elem</span><span class="o">).</span><span class="n">iterator</span><span class="o">());</span>
          <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Finally, to demonstrate all of the stages above, we put them together into a processing chain,
which conceptually would correspond to the following structure:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_chain.png"><img alt="../../_images/graph_stage_chain.png" class="align-center" src="../../_images/graph_stage_chain.png" style="width: 700px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>In code this is only a few lines, using the <code class="docutils literal"><span class="pre">via</span></code> use our custom stages in a stream:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resultFuture</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="n">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">))</span>
        <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">Filter</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;((</span><span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span>
        <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">Duplicator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;())</span>
        <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="k">new</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;((</span><span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">))</span>
        <span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">mat</span><span class="o">);</span>
</pre></div>
</div>
<p>If we attempt to draw the sequence of events, it shows that there is one &quot;event token&quot;
in circulation in a potential chain of stages, just like our conceptual &quot;railroad tracks&quot; representation predicts.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_tracks_1.png"><img alt="../../_images/graph_stage_tracks_1.png" class="align-center" src="../../_images/graph_stage_tracks_1.png" style="width: 700px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="completion">
<h3>Completion</h3>
<p>Completion handling usually (but not exclusively) comes into the picture when processing stages need to emit
a few more elements after their upstream source has been completed. We have seen an example of this in our
first <code class="xref py py-class docutils literal"><span class="pre">Duplicator</span></code> implementation where the last element needs to be doubled even after the upstream neighbor
stage has been completed. This can be done by overriding the <code class="docutils literal"><span class="pre">onUpstreamFinish</span></code> method in <code class="docutils literal"><span class="pre">AbstractInHandler</span></code>.</p>
<p>Stages by default automatically stop once all of their ports (input and output) have been closed externally or internally.
It is possible to opt out from this behavior by invoking <code class="docutils literal"><span class="pre">setKeepGoing(true)</span></code> (which is not supported from the stage’s
constructor and usually done in <code class="docutils literal"><span class="pre">preStart</span></code>). In this case the stage <strong>must</strong> be explicitly closed by calling <code class="docutils literal"><span class="pre">completeStage()</span></code>
or <code class="docutils literal"><span class="pre">failStage(exception)</span></code>. This feature carries the risk of leaking streams and actors, therefore it should be used
with care.</p>
</div>
<div class="section" id="using-timers">
<h3>Using timers</h3>
<p>It is possible to use timers in <code class="xref py py-class docutils literal"><span class="pre">GraphStages</span></code> by using <code class="xref py py-class docutils literal"><span class="pre">TimerGraphStageLogic</span></code> as the base class for
the returned logic. Timers can be scheduled by calling one of <code class="docutils literal"><span class="pre">scheduleOnce(key,delay)</span></code>, <code class="docutils literal"><span class="pre">schedulePeriodically(key,period)</span></code> or
<code class="docutils literal"><span class="pre">schedulePeriodicallyWithInitialDelay(key,delay,period)</span></code> and passing an object as a key for that timer (can be any object, for example
a <code class="xref py py-class docutils literal"><span class="pre">String</span></code>). The <code class="docutils literal"><span class="pre">onTimer(key)</span></code> method needs to be overridden and it will be called once the timer of <code class="docutils literal"><span class="pre">key</span></code>
fires. It is possible to cancel a timer using <code class="docutils literal"><span class="pre">cancelTimer(key)</span></code> and check the status of a timer with
<code class="docutils literal"><span class="pre">isTimerActive(key)</span></code>. Timers will be automatically cleaned up when the stage completes.</p>
<p>Timers can not be scheduled from the constructor of the logic, but it is possible to schedule them from the
<code class="docutils literal"><span class="pre">preStart()</span></code> lifecycle hook.</p>
<p>In this sample the stage toggles between open and closed, where open means no elements are passed through. The
stage starts out as closed but as soon as an element is pushed downstream the gate becomes open for a duration
of time during which it will consume and drop upstream messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// each time an event is pushed through it will trigger a period of silence</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">TimedGate</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FiniteDuration</span> <span class="n">silencePeriod</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">TimedGate</span><span class="o">(</span><span class="nc">FiniteDuration</span> <span class="n">silencePeriod</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">silencePeriod</span> <span class="k">=</span> <span class="n">silencePeriod</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;TimedGate.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;TimedGate.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">TimerGraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">private</span> <span class="n">boolean</span> <span class="n">open</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">open</span><span class="o">)</span> <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">elem</span><span class="o">);</span>
              <span class="n">open</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
              <span class="n">scheduleOnce</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">,</span> <span class="n">silencePeriod</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">onTimer</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">open</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-asynchronous-side-channels">
<h3>Using asynchronous side-channels</h3>
<p>In order to receive asynchronous events that are not arriving as stream elements (for example a completion of a future
or a callback from a 3rd party API) one must acquire a <code class="xref py py-class docutils literal"><span class="pre">AsyncCallback</span></code> by calling <code class="docutils literal"><span class="pre">getAsyncCallback()</span></code> from the
stage logic. The method <code class="docutils literal"><span class="pre">getAsyncCallback</span></code> takes as a parameter a callback that will be called once the asynchronous
event fires. It is important to <strong>not call the callback directly</strong>, instead, the external API must call the
<code class="docutils literal"><span class="pre">invoke(event)</span></code> method on the returned <code class="xref py py-class docutils literal"><span class="pre">AsyncCallback</span></code>. The execution engine will take care of calling the
provided callback in a thread-safe way. The callback can safely access the state of the <code class="xref py py-class docutils literal"><span class="pre">GraphStageLogic</span></code>
implementation.</p>
<p>Sharing the AsyncCallback from the constructor risks race conditions, therefore it is recommended to use the
<code class="docutils literal"><span class="pre">preStart()</span></code> lifecycle hook instead.</p>
<p>This example shows an asynchronous side channel graph stage that starts dropping elements
when a future completes:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// will close upstream in all materializations of the stage instance</span>
<span class="c1">// when the completion stage completes</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">KillSwitch</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;</span> <span class="n">switchF</span><span class="o">;</span>

  <span class="n">public</span> <span class="nc">KillSwitch</span><span class="o">(</span><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;</span> <span class="n">switchF</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="n">switchF</span> <span class="k">=</span> <span class="n">switchF</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;KillSwitch.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;KillSwitch.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">));</span>
          <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">AsyncCallback</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;</span> <span class="n">callback</span> <span class="k">=</span> <span class="n">createAsyncCallback</span><span class="o">(</span><span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">Done</span><span class="o">&gt;()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Done</span> <span class="n">param</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">completeStage</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">});</span>

        <span class="nc">ExecutionContext</span> <span class="n">ec</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">();</span>
        <span class="n">switchF</span><span class="o">.</span><span class="n">thenAccept</span><span class="o">(</span><span class="n">callback</span><span class="o">::</span><span class="n">invoke</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="integration-with-actors">
<h3>Integration with actors</h3>
<p><strong>This section is a stub and will be extended in the next release</strong>
<strong>This is an experimental feature*</strong></p>
<p>It is possible to acquire an ActorRef that can be addressed from the outside of the stage, similarly how
<code class="xref py py-class docutils literal"><span class="pre">AsyncCallback</span></code> allows injecting asynchronous events into a stage logic. This reference can be obtained
by calling <code class="docutils literal"><span class="pre">getStageActorRef(receive)</span></code> passing in a function that takes a <code class="xref py py-class docutils literal"><span class="pre">Pair</span></code> of the sender
<code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> and the received message. This reference can be used to watch other actors by calling its <code class="docutils literal"><span class="pre">watch(ref)</span></code>
or <code class="docutils literal"><span class="pre">unwatch(ref)</span></code> methods. The reference can be also watched by external actors. The current limitations of this
<code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> are:</p>
<blockquote>
<div><ul class="simple">
<li>they are not location transparent, they cannot be accessed via remoting.</li>
<li>they cannot be returned as materialized values.</li>
<li>they cannot be accessed from the constructor of the <code class="xref py py-class docutils literal"><span class="pre">GraphStageLogic</span></code>, but they can be accessed from the
<code class="docutils literal"><span class="pre">preStart()</span></code> method.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="custom-materialized-values">
<h3>Custom materialized values</h3>
<p>Custom stages can return materialized values instead of <code class="docutils literal"><span class="pre">Unit</span></code> by inheriting from <code class="xref py py-class docutils literal"><span class="pre">GraphStageWithMaterializedValue</span></code>
instead of the simpler <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code>. The difference is that in this case the method
<code class="docutils literal"><span class="pre">createLogicAndMaterializedValue(inheritedAttributes)</span></code> needs to be overridden, and in addition to the
stage logic the materialized value must be provided</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">There is no built-in synchronization of accessing this value from both of the thread where the logic runs and
the thread that got hold of the materialized value. It is the responsibility of the programmer to add the
necessary (non-blocking) synchronization and visibility guarantees to this shared object.</p>
</div>
<p>In this sample the materialized value is a future containing the first element to go through the stream:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">FirstValue</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStageWithMaterializedValue</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;,</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;FirstValue.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;FirstValue.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">GraphStageLogic</span><span class="o">,</span> <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span> <span class="n">createLogicAndMaterializedValue</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Promise</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">promise</span> <span class="k">=</span> <span class="nc">Futures</span><span class="o">.</span><span class="n">promise</span><span class="o">();</span>

    <span class="nc">GraphStageLogic</span> <span class="n">logic</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">promise</span><span class="o">.</span><span class="n">success</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
            <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">elem</span><span class="o">);</span>

            <span class="c1">// replace handler with one just forwarding</span>
            <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
              <span class="nd">@Override</span>
              <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">));</span>
              <span class="o">}</span>
            <span class="o">});</span>
          <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">logic</span><span class="o">,</span> <span class="n">promise</span><span class="o">.</span><span class="n">future</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-attributes-to-affect-the-behavior-of-a-stage">
<h3>Using attributes to affect the behavior of a stage</h3>
<p><strong>This section is a stub and will be extended in the next release</strong></p>
<p>Stages can access the <code class="xref py py-class docutils literal"><span class="pre">Attributes</span></code> object created by the materializer. This contains all the applied (inherited)
attributes applying to the stage, ordered from least specific (outermost) towards the most specific (innermost)
attribute. It is the responsibility of the stage to decide how to reconcile this inheritance chain to a final effective
decision.</p>
<p>See <a class="reference internal" href="stream-composition.html#composition-java"><span class="std std-ref">Modularity, Composition and Hierarchy</span></a> for an explanation on how attributes work.</p>
</div>
<div class="section" id="rate-decoupled-graph-stages">
<h3>Rate decoupled graph stages</h3>
<p>Sometimes it is desirable to <em>decouple</em> the rate of the upstream and downstream of a stage, synchronizing only
when needed.</p>
<p>This is achieved in the model by representing a <code class="xref py py-class docutils literal"><span class="pre">GraphStage</span></code> as a <em>boundary</em> between two regions where the
demand sent upstream is decoupled from the demand that arrives from downstream. One immediate consequence of this
difference is that an <code class="docutils literal"><span class="pre">onPush</span></code> call does not always lead to calling <code class="docutils literal"><span class="pre">push</span></code> and an <code class="docutils literal"><span class="pre">onPull</span></code>  call does not always
lead to calling <code class="docutils literal"><span class="pre">pull</span></code>.</p>
<p>One of the important use-case for this is to build buffer-like entities, that allow independent progress
of upstream and downstream stages when the buffer is not full or empty, and slowing down the appropriate side if the
buffer becomes empty or full.</p>
<p>The next diagram illustrates the event sequence for a buffer with capacity of two elements in a setting where
the downstream demand is slow to start and the buffer will fill up with upstream elements before any demand
is seen from downstream.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_detached_tracks_1.png"><img alt="../../_images/graph_stage_detached_tracks_1.png" class="align-center" src="../../_images/graph_stage_detached_tracks_1.png" style="width: 500px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Another scenario would be where the demand from downstream starts coming in before any element is pushed
into the buffer stage.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="../../_images/graph_stage_detached_tracks_2.png"><img alt="../../_images/graph_stage_detached_tracks_2.png" class="align-center" src="../../_images/graph_stage_detached_tracks_2.png" style="width: 500px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The first difference we can notice is that our <code class="docutils literal"><span class="pre">Buffer</span></code> stage is automatically pulling its upstream on
initialization. The buffer has demand for up to two elements without any downstream demand.</p>
<p>The following code example demonstrates a buffer class corresponding to the message sequence chart above.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">TwoBuffer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="nc">GraphStage</span><span class="o">&lt;</span><span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

  <span class="n">public</span> <span class="k">final</span> <span class="nc">Inlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Inlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;TwoBuffer.in&quot;</span><span class="o">);</span>
  <span class="n">public</span> <span class="k">final</span> <span class="nc">Outlet</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">out</span> <span class="k">=</span> <span class="nc">Outlet</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;TwoBuffer.out&quot;</span><span class="o">);</span>

  <span class="k">private</span> <span class="k">final</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span> <span class="k">=</span> <span class="nc">FlowShape</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">FlowShape</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">shape</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">GraphStageLogic</span> <span class="n">createLogic</span><span class="o">(</span><span class="nc">Attributes</span> <span class="n">inheritedAttributes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">GraphStageLogic</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">private</span> <span class="k">final</span> <span class="n">int</span> <span class="nc">SIZE</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
      <span class="k">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;(</span><span class="nc">SIZE</span><span class="o">);</span>
      <span class="k">private</span> <span class="n">boolean</span> <span class="n">downstreamWaiting</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>

      <span class="k">private</span> <span class="n">boolean</span> <span class="n">isBufferFull</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="o">()</span> <span class="o">==</span> <span class="nc">SIZE</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// a detached stage needs to start upstream demand</span>
        <span class="c1">// itself as it is not triggered by downstream demand</span>
        <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="o">{</span>
        <span class="n">setHandler</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractInHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPush</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">grab</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="n">buffer</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">downstreamWaiting</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">downstreamWaiting</span> <span class="k">=</span> <span class="kc">false</span><span class="o">;</span>
              <span class="n">A</span> <span class="n">bufferedElem</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">poll</span><span class="o">();</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">bufferedElem</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isBufferFull</span><span class="o">())</span> <span class="o">{</span>
              <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>

          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onUpstreamFinish</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">buffer</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
              <span class="c1">// emit the rest if possible</span>
              <span class="n">emitMultiple</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="n">iterator</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="n">completeStage</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">});</span>


        <span class="n">setHandler</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AbstractOutHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="n">public</span> <span class="n">void</span> <span class="n">onPull</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
              <span class="n">downstreamWaiting</span> <span class="k">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="n">A</span> <span class="n">elem</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">poll</span><span class="o">();</span>
              <span class="n">push</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">elem</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isBufferFull</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasBeenPulled</span><span class="o">(</span><span class="n">in</span><span class="o">))</span> <span class="o">{</span>
              <span class="n">pull</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">});</span>
      <span class="o">}</span>
    <span class="o">};</span>

  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="thread-safety-of-custom-processing-stages">
<h2>Thread safety of custom processing stages</h2>
<dl class="docutils">
<dt>All of the above custom stages (linear or graph) provide a few simple guarantees that implementors can rely on.</dt>
<dd><ul class="first last simple">
<li>The callbacks exposed by all of these classes are never called concurrently.</li>
<li>The state encapsulated by these classes can be safely modified from the provided callbacks, without any further
synchronization.</li>
</ul>
</dd>
</dl>
<p>In essence, the above guarantees are similar to what <code class="xref py py-class docutils literal"><span class="pre">Actor</span></code> s provide, if one thinks of the state of a custom
stage as state of an actor, and the callbacks as the <code class="docutils literal"><span class="pre">receive</span></code> block of the actor.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">It is <strong>not safe</strong> to access the state of any custom stage outside of the callbacks that it provides, just like it
is unsafe to access the state of an actor from the outside. This means that Future callbacks should <strong>not close over</strong>
internal state of custom stages because such access can be concurrent with the provided callbacks, leading to undefined
behavior.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: 10月 15, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>