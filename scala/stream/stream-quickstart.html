

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>クイックスタートガイド &#8212; Akka Documentation</title>
    
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '@version@',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="../../_static/toc.js"></script>
    <script type="text/javascript" src="../../_static/prettify.js"></script>
    <script type="text/javascript" src="../../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../../_static/effects.core.js"></script>
    <script type="text/javascript" src="../../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../../_static/ga.js"></script>
    <script type="text/javascript" src="../../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../../index.html" />
    <link rel="up" title="ストリーム" href="index.html" />
    <link rel="next" title="Basics and working with Flows" href="stream-flows-and-basics.html" />
    <link rel="prev" title="イントロダクション" href="stream-introduction.html" />


  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">クイックスタートガイド</div>
      <div class="pdf-link"><a href="../../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../../AkkaJava.pdf" title="Akka Java Documentation"><img src="../../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="stream-flows-and-basics.html">Basics and working with Flows</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../../java.html">Java Contents</a> <span class="divider">|</span> <a href="../../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="stream-introduction.html">イントロダクション</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version @version@
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="quick-start-guide">
<span id="stream-quickstart-scala"></span><h1>クイックスタートガイド</h1>
<p>ストリームは基本的にはソースから始まります。Akka Stream を始める場合も然りです。しかしまずは、ストリーミングのために必要な道具をインポートしてみましょう。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.stream._</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl._</span>
</pre></div>
</div>
<p>このクイックスタートガイドを読みつつサンプルコードを実行したい場合、以下のインポートも必要になります。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.</span><span class="o">{</span> <span class="nc">NotUsed</span><span class="o">,</span> <span class="nc">Done</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.util.ByteString</span>
<span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">java.nio.file.Paths</span>
</pre></div>
</div>
<p>さて、まずは整数値を 1 から 100 まで発行するシンプルなソースから始めてゆきましょう。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">source</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">NotUsed</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span><span class="o">)</span>
</pre></div>
</div>
<p><em>TBD</em> <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> 型は2つの型パラメータを取ります。一つ目がソースが発行する個別要素の型を示し、二つ目が、実行中のソースが生成する補助的な値を示します（##???##）(例えばネットワークソースは、接続先のポートや通信先のアドレスに関する情報を提供します)。 補助的な情報が生成されない場合、ここには <code class="docutils literal"><span class="pre">akka.NotUsed</span></code> という型が使われます。例えば整数の範囲をストリームとして扱う場合、これに相当します。</p>
<p>このソースを作成したということは、1から100までの整数を発行するためのレシピが作成されたということです。しかしソースはまだアクティブにはなっていません。これらの整数を手にするには、次のようなコードを実行する必要があります。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">source</span><span class="o">.</span><span class="n">runForeach</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">))(</span><span class="n">materializer</span><span class="o">)</span>
</pre></div>
</div>
<p>This line will complement the source with a consumer function—in this example
we simply print out the numbers to the console—and pass this little stream
setup to an Actor that runs it. This activation is signaled by having “run” be
part of the method name; there are other methods that run Akka Streams, and
they all follow this pattern.</p>
<p>You may wonder where the Actor gets created that runs the stream, and you are
probably also asking yourself what this <code class="docutils literal"><span class="pre">materializer</span></code> means. In order to get
this value we first need to create an Actor system:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;QuickStart&quot;</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
</pre></div>
</div>
<p>There are other ways to create a materializer, e.g. from an
<code class="xref py py-class docutils literal"><span class="pre">ActorContext</span></code> when using streams from within Actors. The
<code class="xref py py-class docutils literal"><span class="pre">Materializer</span></code> is a factory for stream execution engines, it is the
thing that makes streams run—you don’t need to worry about any of the details
just now apart from that you need one for calling any of the <code class="docutils literal"><span class="pre">run</span></code> methods on
a <code class="xref py py-class docutils literal"><span class="pre">Source</span></code>. The materializer is picked up implicitly if it is omitted
from the <code class="docutils literal"><span class="pre">run</span></code> method call arguments, which we will do in the following.</p>
<p>The nice thing about Akka Streams is that the <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> is just a
description of what you want to run, and like an architect’s blueprint it can
be reused, incorporated into a larger design. We may choose to transform the
source of integers and write it to a file instead:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">factorials</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">scan</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">))((</span><span class="n">acc</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">next</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">IOResult</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">factorials</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">num</span> <span class="k">=&gt;</span> <span class="nc">ByteString</span><span class="o">(</span><span class="s">s&quot;</span><span class="si">$num</span><span class="s">\n&quot;</span><span class="o">))</span>
    <span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">FileIO</span><span class="o">.</span><span class="n">toPath</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">&quot;factorials.txt&quot;</span><span class="o">)))</span>
</pre></div>
</div>
<p>First we use the <code class="docutils literal"><span class="pre">scan</span></code> combinator to run a computation over the whole
stream: starting with the number 1 (<code class="docutils literal"><span class="pre">BigInt(1)</span></code>) we multiple by each of
the incoming numbers, one after the other; the scan operation emits the initial
value and then every calculation result. This yields the series of factorial
numbers which we stash away as a <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> for later reuse—it is
important to keep in mind that nothing is actually computed yet, this is just a
description of what we want to have computed once we run the stream. Then we
convert the resulting series of numbers into a stream of <code class="xref py py-class docutils literal"><span class="pre">ByteString</span></code>
objects describing lines in a text file. This stream is then run by attaching a
file as the receiver of the data. In the terminology of Akka Streams this is
called a <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code>. <code class="xref py py-class docutils literal"><span class="pre">IOResult</span></code> is a type that IO operations return in
Akka Streams in order to tell you how many bytes or elements were consumed and
whether the stream terminated normally or exceptionally.</p>
<div class="section" id="reusable-pieces">
<h2>Reusable Pieces</h2>
<p>One of the nice parts of Akka Streams—and something that other stream libraries
do not offer—is that not only sources can be reused like blueprints, all other
elements can be as well. We can take the file-writing <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code>, prepend
the processing steps necessary to get the <code class="xref py py-class docutils literal"><span class="pre">ByteString</span></code> elements from
incoming strings and package that up as a reusable piece as well. Since the
language for writing these streams always flows from left to right (just like
plain English), we need a starting point that is like a source but with an
“open” input. In Akka Streams this is called a <code class="xref py py-class docutils literal"><span class="pre">Flow</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lineSink</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sink</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Future</span><span class="o">[</span><span class="kt">IOResult</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Flow</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">ByteString</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span><span class="o">))</span>
    <span class="o">.</span><span class="n">toMat</span><span class="o">(</span><span class="nc">FileIO</span><span class="o">.</span><span class="n">toPath</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">filename</span><span class="o">)))(</span><span class="nc">Keep</span><span class="o">.</span><span class="n">right</span><span class="o">)</span>
</pre></div>
</div>
<p>Starting from a flow of strings we convert each to <code class="xref py py-class docutils literal"><span class="pre">ByteString</span></code> and then
feed to the already known file-writing <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code>. The resulting blueprint
is a <code class="xref py py-class docutils literal"><span class="pre">Sink[String,</span> <span class="pre">Future[IOResult]]</span></code>, which means that it
accepts strings as its input and when materialized it will create auxiliary
information of type <code class="docutils literal"><span class="pre">Future[IOResult]</span></code> (when chaining operations on
a <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> or <code class="xref py py-class docutils literal"><span class="pre">Flow</span></code> the type of the auxiliary information—called
the “materialized value”—is given by the leftmost starting point; since we want
to retain what the <code class="docutils literal"><span class="pre">FileIO.toPath</span></code> sink has to offer, we need to say
<code class="docutils literal"><span class="pre">Keep.right</span></code>).</p>
<p>We can use the new and shiny <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code> we just created by
attaching it to our <code class="docutils literal"><span class="pre">factorials</span></code> source—after a small adaptation to turn the
numbers into strings:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">factorials</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">).</span><span class="n">runWith</span><span class="o">(</span><span class="n">lineSink</span><span class="o">(</span><span class="s">&quot;factorial2.txt&quot;</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="time-based-processing">
<h2>Time-Based Processing</h2>
<p>Before we start looking at a more involved example we explore the streaming
nature of what Akka Streams can do. Starting from the <code class="docutils literal"><span class="pre">factorials</span></code> source
we transform the stream by zipping it together with another stream,
represented by a <code class="xref py py-class docutils literal"><span class="pre">Source</span></code> that emits the number 0 to 100: the first
number emitted by the <code class="docutils literal"><span class="pre">factorials</span></code> source is the factorial of zero, the
second is the factorial of one, and so on. We combine these two by forming
strings like <code class="docutils literal"><span class="pre">&quot;3!</span> <span class="pre">=</span> <span class="pre">6&quot;</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">done</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Done</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">factorials</span>
    <span class="o">.</span><span class="n">zipWith</span><span class="o">(</span><span class="nc">Source</span><span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">100</span><span class="o">))((</span><span class="n">num</span><span class="o">,</span> <span class="n">idx</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;</span><span class="si">$idx</span><span class="s">! = </span><span class="si">$num</span><span class="s">&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">throttle</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">1.</span><span class="n">second</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">ThrottleMode</span><span class="o">.</span><span class="n">shaping</span><span class="o">)</span>
    <span class="o">.</span><span class="n">runForeach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div>
</div>
<p>All operations so far have been time-independent and could have been performed
in the same fashion on strict collections of elements. The next line
demonstrates that we are in fact dealing with streams that can flow at a
certain speed: we use the <code class="docutils literal"><span class="pre">throttle</span></code> combinator to slow down the stream to 1
element per second (the second <code class="docutils literal"><span class="pre">1</span></code> in the argument list is the maximum size
of a burst that we want to allow—passing <code class="docutils literal"><span class="pre">1</span></code> means that the first element
gets through immediately and the second then has to wait for one second and so
on).</p>
<p>If you run this program you will see one line printed per second. One aspect
that is not immediately visible deserves mention, though: if you try and set
the streams to produce a billion numbers each then you will notice that your
JVM does not crash with an OutOfMemoryError, even though you will also notice
that running the streams happens in the background, asynchronously (this is the
reason for the auxiliary information to be provided as a <code class="xref py py-class docutils literal"><span class="pre">Future</span></code>). The
secret that makes this work is that Akka Streams implicitly implement pervasive
flow control, all combinators respect back-pressure. This allows the throttle
combinator to signal to all its upstream sources of data that it can only
accept elements at a certain rate—when the incoming rate is higher than one per
second the throttle combinator will assert <em>back-pressure</em> upstream.</p>
<p>This is basically all there is to Akka Streams in a nutshell—glossing over the
fact that there are dozens of sources and sinks and many more stream
transformation combinators to choose from, see also <a class="reference internal" href="stages-overview.html#stages-overview-scala"><span class="std std-ref">Overview of built-in stages and their semantics</span></a>.</p>
</div>
</div>
<div class="section" id="reactive-tweets">
<h1>Reactive Tweets</h1>
<p>A typical use case for stream processing is consuming a live stream of data that we want to extract or aggregate some
other data from. In this example we'll consider consuming a stream of tweets and extracting information concerning Akka from them.</p>
<p>We will also consider the problem inherent to all non-blocking streaming
solutions: <em>&quot;What if the subscriber is too slow to consume the live stream of
data?&quot;</em>. Traditionally the solution is often to buffer the elements, but this
can—and usually will—cause eventual buffer overflows and instability of such
systems. Instead Akka Streams depend on internal backpressure signals that
allow to control what should happen in such scenarios.</p>
<p>Here's the data model we'll be working with throughout the quickstart examples:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Author</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Hashtag</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Tweet</span><span class="o">(</span><span class="n">author</span><span class="k">:</span> <span class="kt">Author</span><span class="o">,</span> <span class="n">timestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">body</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hashtags</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Hashtag</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">body</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">t</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;#&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Hashtag</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">}.</span><span class="n">toSet</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">akka</span> <span class="k">=</span> <span class="nc">Hashtag</span><span class="o">(</span><span class="s">&quot;#akka&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you would like to get an overview of the used vocabulary first instead of diving head-first
into an actual example you can have a look at the <a class="reference internal" href="stream-flows-and-basics.html#core-concepts-scala"><span class="std std-ref">Core concepts</span></a> and <a class="reference internal" href="stream-flows-and-basics.html#defining-and-running-streams-scala"><span class="std std-ref">Defining and running streams</span></a>
sections of the docs, and then come back to this quickstart to see it all pieced together into a simple example application.</p>
</div>
<div class="section" id="transforming-and-consuming-simple-streams">
<h2>Transforming and consuming simple streams</h2>
<p>The example application we will be looking at is a simple Twitter feed stream from which we'll want to extract certain information,
like for example finding all twitter handles of users who tweet about <code class="docutils literal"><span class="pre">#akka</span></code>.</p>
<p>In order to prepare our environment by creating an <code class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></code> and <code class="xref py py-class docutils literal"><span class="pre">ActorMaterializer</span></code>,
which will be responsible for materializing and running the streams we are about to create:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;reactive-tweets&quot;</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal"><span class="pre">ActorMaterializer</span></code> can optionally take <code class="xref py py-class docutils literal"><span class="pre">ActorMaterializerSettings</span></code> which can be used to define
materialization properties, such as default buffer sizes (see also <a class="reference internal" href="stream-rate.html#async-stream-buffers-scala"><span class="std std-ref">Buffers for asynchronous stages</span></a>), the dispatcher to
be used by the pipeline etc. These can be overridden with <code class="docutils literal"><span class="pre">withAttributes</span></code> on <code class="xref py py-class docutils literal"><span class="pre">Flow</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Source</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code> and <code class="xref py py-class docutils literal"><span class="pre">Graph</span></code>.</p>
<p>Let's assume we have a stream of tweets readily available. In Akka this is expressed as a <code class="xref py py-class docutils literal"><span class="pre">Source[Out,</span> <span class="pre">M]</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">tweets</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Tweet</span>, <span class="kt">NotUsed</span><span class="o">]</span>
</pre></div>
</div>
<p>Streams always start flowing from a <code class="xref py py-class docutils literal"><span class="pre">Source[Out,M1]</span></code> then can continue through <code class="xref py py-class docutils literal"><span class="pre">Flow[In,Out,M2]</span></code> elements or
more advanced graph elements to finally be consumed by a <code class="xref py py-class docutils literal"><span class="pre">Sink[In,M3]</span></code> (ignore the type parameters <code class="docutils literal"><span class="pre">M1</span></code>, <code class="docutils literal"><span class="pre">M2</span></code>
and <code class="docutils literal"><span class="pre">M3</span></code> for now, they are not relevant to the types of the elements produced/consumed by these classes – they are
&quot;materialized types&quot;, which we'll talk about <a class="reference internal" href="#materialized-values-quick-scala"><span class="std std-ref">below</span></a>).</p>
<p>The operations should look familiar to anyone who has used the Scala Collections library,
however they operate on streams and not collections of data (which is a very important distinction, as some operations
only make sense in streaming and vice versa):</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Author</span>, <span class="kt">NotUsed</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">tweets</span>
    <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashtags</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">akka</span><span class="o">))</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">author</span><span class="o">)</span>
</pre></div>
</div>
<p>Finally in order to <a class="reference internal" href="stream-flows-and-basics.html#stream-materialization-scala"><span class="std std-ref">materialize</span></a> and run the stream computation we need to attach
the Flow to a <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code> that will get the Flow running. The simplest way to do this is to call
<code class="docutils literal"><span class="pre">runWith(sink)</span></code> on a <code class="docutils literal"><span class="pre">Source</span></code>. For convenience a number of common Sinks are predefined and collected as methods on
the <code class="xref py py-class docutils literal"><span class="pre">Sink</span></code> <a class="reference external" href="http://doc.akka.io/api/akka-stream-and-http-experimental/&#64;version&#64;/#akka.stream.scaladsl.Sink$">companion object</a>.
For now let's simply print each author:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">authors</span><span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">))</span>
</pre></div>
</div>
<p>or by using the shorthand version (which are defined only for the most popular Sinks such as <code class="docutils literal"><span class="pre">Sink.fold</span></code> and <code class="docutils literal"><span class="pre">Sink.foreach</span></code>):</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">authors</span><span class="o">.</span><span class="n">runForeach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div>
</div>
<p>Materializing and running a stream always requires a <code class="xref py py-class docutils literal"><span class="pre">Materializer</span></code> to be in implicit scope (or passed in explicitly,
like this: <code class="docutils literal"><span class="pre">.run(materializer)</span></code>).</p>
<p>The complete snippet looks like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;reactive-tweets&quot;</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>

<span class="k">val</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Author</span>, <span class="kt">NotUsed</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">tweets</span>
    <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashtags</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">akka</span><span class="o">))</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">author</span><span class="o">)</span>

<span class="n">authors</span><span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="flattening-sequences-in-streams">
<h2>Flattening sequences in streams</h2>
<p>In the previous section we were working on 1:1 relationships of elements which is the most common case, but sometimes
we might want to map from one element to a number of elements and receive a &quot;flattened&quot; stream, similarly like <code class="docutils literal"><span class="pre">flatMap</span></code>
works on Scala Collections. In order to get a flattened stream of hashtags from our stream of tweets we can use the <code class="docutils literal"><span class="pre">mapConcat</span></code>
combinator:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">hashtags</span><span class="k">:</span> <span class="kt">Source</span><span class="o">[</span><span class="kt">Hashtag</span>, <span class="kt">NotUsed</span><span class="o">]</span> <span class="k">=</span> <span class="n">tweets</span><span class="o">.</span><span class="n">mapConcat</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashtags</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>The name <code class="docutils literal"><span class="pre">flatMap</span></code> was consciously avoided due to its proximity with for-comprehensions and monadic composition.
It is problematic for two reasons: first, flattening by concatenation is often undesirable in bounded stream processing
due to the risk of deadlock (with merge being the preferred strategy), and second, the monad laws would not hold for
our implementation of flatMap (due to the liveness issues).</p>
<p class="last">Please note that the <code class="docutils literal"><span class="pre">mapConcat</span></code> requires the supplied function to return a strict collection (<code class="docutils literal"><span class="pre">f:Out=&gt;immutable.Seq[T]</span></code>),
whereas <code class="docutils literal"><span class="pre">flatMap</span></code> would have to operate on streams all the way through.</p>
</div>
</div>
<div class="section" id="broadcasting-a-stream">
<h2>Broadcasting a stream</h2>
<p>Now let's say we want to persist all hashtags, as well as all author names from this one live stream.
For example we'd like to write all author handles into one file, and all hashtags into another file on disk.
This means we have to split the source stream into two streams which will handle the writing to these different files.</p>
<p>Elements that can be used to form such &quot;fan-out&quot; (or &quot;fan-in&quot;) structures are referred to as &quot;junctions&quot; in Akka Streams.
One of these that we'll be using in this example is called <code class="xref py py-class docutils literal"><span class="pre">Broadcast</span></code>, and it simply emits elements from its
input port to all of its output ports.</p>
<p>Akka Streams intentionally separate the linear stream structures (Flows) from the non-linear, branching ones (Graphs)
in order to offer the most convenient API for both of these cases. Graphs can express arbitrarily complex stream setups
at the expense of not reading as familiarly as collection transformations.</p>
<p>Graphs are constructed using <code class="xref py py-class docutils literal"><span class="pre">GraphDSL</span></code> like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">writeAuthors</span><span class="k">:</span> <span class="kt">Sink</span><span class="o">[</span><span class="kt">Author</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">val</span> <span class="n">writeHashtags</span><span class="k">:</span> <span class="kt">Sink</span><span class="o">[</span><span class="kt">Hashtag</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="nc">RunnableGraph</span><span class="o">.</span><span class="n">fromGraph</span><span class="o">(</span><span class="nc">GraphDSL</span><span class="o">.</span><span class="n">create</span><span class="o">()</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">b</span> <span class="k">=&gt;</span>
  <span class="k">import</span> <span class="nn">GraphDSL.Implicits._</span>

  <span class="k">val</span> <span class="n">bcast</span> <span class="k">=</span> <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Broadcast</span><span class="o">[</span><span class="kt">Tweet</span><span class="o">](</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">tweets</span> <span class="o">~&gt;</span> <span class="n">bcast</span><span class="o">.</span><span class="n">in</span>
  <span class="n">bcast</span><span class="o">.</span><span class="n">out</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">Tweet</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">author</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="n">writeAuthors</span> 
  <span class="n">bcast</span><span class="o">.</span><span class="n">out</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">Tweet</span><span class="o">].</span><span class="n">mapConcat</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashtags</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="n">writeHashtags</span>
  <span class="nc">ClosedShape</span>
<span class="o">})</span>
<span class="n">g</span><span class="o">.</span><span class="n">run</span><span class="o">()</span>
</pre></div>
</div>
<p>As you can see, inside the <code class="xref py py-class docutils literal"><span class="pre">GraphDSL</span></code> we use an implicit graph builder <code class="docutils literal"><span class="pre">b</span></code> to mutably construct the graph
using the <code class="docutils literal"><span class="pre">~&gt;</span></code> &quot;edge operator&quot; (also read as &quot;connect&quot; or &quot;via&quot; or &quot;to&quot;). The operator is provided implicitly
by importing <code class="docutils literal"><span class="pre">GraphDSL.Implicits._</span></code>.</p>
<p><code class="docutils literal"><span class="pre">GraphDSL.create</span></code> returns a <code class="xref py py-class docutils literal"><span class="pre">Graph</span></code>, in this example a <code class="xref py py-class docutils literal"><span class="pre">Graph[ClosedShape,</span> <span class="pre">Unit]</span></code> where
<code class="xref py py-class docutils literal"><span class="pre">ClosedShape</span></code> means that it is <em>a fully connected graph</em> or &quot;closed&quot; - there are no unconnected inputs or outputs.
Since it is closed it is possible to transform the graph into a <code class="xref py py-class docutils literal"><span class="pre">RunnableGraph</span></code> using <code class="docutils literal"><span class="pre">RunnableGraph.fromGraph</span></code>.
The runnable graph can then be <code class="docutils literal"><span class="pre">run()</span></code> to materialize a stream out of it.</p>
<p>Both <code class="xref py py-class docutils literal"><span class="pre">Graph</span></code> and <code class="xref py py-class docutils literal"><span class="pre">RunnableGraph</span></code> are <em>immutable, thread-safe, and freely shareable</em>.</p>
<p>A graph can also have one of several other shapes, with one or more unconnected ports. Having unconnected ports
expresses a graph that is a <em>partial graph</em>. Concepts around composing and nesting graphs in large structures are
explained in detail in <a class="reference internal" href="stream-composition.html#composition-scala"><span class="std std-ref">Modularity, Composition and Hierarchy</span></a>. It is also possible to wrap complex computation graphs
as Flows, Sinks or Sources, which will be explained in detail in
<a class="reference internal" href="stream-graphs.html#constructing-sources-sinks-flows-from-partial-graphs-scala"><span class="std std-ref">Constructing Sources, Sinks and Flows from Partial Graphs</span></a>.</p>
</div>
<div class="section" id="back-pressure-in-action">
<h2>Back-pressure in action</h2>
<p>One of the main advantages of Akka Streams is that they <em>always</em> propagate back-pressure information from stream Sinks
(Subscribers) to their Sources (Publishers). It is not an optional feature, and is enabled at all times. To learn more
about the back-pressure protocol used by Akka Streams and all other Reactive Streams compatible implementations read
<a class="reference internal" href="stream-flows-and-basics.html#back-pressure-explained-scala"><span class="std std-ref">Back-pressure explained</span></a>.</p>
<p>A typical problem applications (not using Akka Streams) like this often face is that they are unable to process the incoming data fast enough,
either temporarily or by design, and will start buffering incoming data until there's no more space to buffer, resulting
in either <code class="docutils literal"><span class="pre">OutOfMemoryError</span></code> s or other severe degradations of service responsiveness. With Akka Streams buffering can
and must be handled explicitly. For example, if we are only interested in the &quot;<em>most recent tweets, with a buffer of 10
elements</em>&quot; this can be expressed using the <code class="docutils literal"><span class="pre">buffer</span></code> element:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">tweets</span>
  <span class="o">.</span><span class="n">buffer</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">OverflowStrategy</span><span class="o">.</span><span class="n">dropHead</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">slowComputation</span><span class="o">)</span>
  <span class="o">.</span><span class="n">runWith</span><span class="o">(</span><span class="nc">Sink</span><span class="o">.</span><span class="n">ignore</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">buffer</span></code> element takes an explicit and required <code class="docutils literal"><span class="pre">OverflowStrategy</span></code>, which defines how the buffer should react
when it receives another element while it is full. Strategies provided include dropping the oldest element (<code class="docutils literal"><span class="pre">dropHead</span></code>),
dropping the entire buffer, signalling errors etc. Be sure to pick and choose the strategy that fits your use case best.</p>
</div>
<div class="section" id="materialized-values">
<span id="materialized-values-quick-scala"></span><h2>Materialized values</h2>
<p>So far we've been only processing data using Flows and consuming it into some kind of external Sink - be it by printing
values or storing them in some external system. However sometimes we may be interested in some value that can be
obtained from the materialized processing pipeline. For example, we want to know how many tweets we have processed.
While this question is not as obvious to give an answer to in case of an infinite stream of tweets (one way to answer
this question in a streaming setting would be to create a stream of counts described as &quot;<em>up until now</em>, we've processed N tweets&quot;),
but in general it is possible to deal with finite streams and come up with a nice result such as a total count of elements.</p>
<p>First, let's write such an element counter using <code class="docutils literal"><span class="pre">Sink.fold</span></code> and see how the types look like:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Flow</span><span class="o">[</span><span class="kt">Tweet</span>, <span class="kt">Int</span>, <span class="kt">NotUsed</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Flow</span><span class="o">[</span><span class="kt">Tweet</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">sumSink</span><span class="k">:</span> <span class="kt">Sink</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Sink</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">](</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="k">val</span> <span class="n">counterGraph</span><span class="k">:</span> <span class="kt">RunnableGraph</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">tweets</span>
    <span class="o">.</span><span class="n">via</span><span class="o">(</span><span class="n">count</span><span class="o">)</span>
    <span class="o">.</span><span class="n">toMat</span><span class="o">(</span><span class="n">sumSink</span><span class="o">)(</span><span class="nc">Keep</span><span class="o">.</span><span class="n">right</span><span class="o">)</span>

<span class="k">val</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">counterGraph</span><span class="o">.</span><span class="n">run</span><span class="o">()</span>

<span class="n">sum</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">s&quot;Total tweets processed: </span><span class="si">$c</span><span class="s">&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>First we prepare a reusable <code class="docutils literal"><span class="pre">Flow</span></code> that will change each incoming tweet into an integer of value <code class="docutils literal"><span class="pre">1</span></code>. We'll use this in
order to combine those with a <code class="docutils literal"><span class="pre">Sink.fold</span></code> that will sum all <code class="docutils literal"><span class="pre">Int</span></code> elements of the stream and make its result available as
a <code class="docutils literal"><span class="pre">Future[Int]</span></code>. Next we connect the <code class="docutils literal"><span class="pre">tweets</span></code> stream to <code class="docutils literal"><span class="pre">count</span></code> with <code class="docutils literal"><span class="pre">via</span></code>. Finally we connect the Flow to the previously
prepared Sink using <code class="docutils literal"><span class="pre">toMat</span></code>.</p>
<p>Remember those mysterious <code class="docutils literal"><span class="pre">Mat</span></code> type parameters on&nbsp;<code class="docutils literal"><span class="pre">Source[+Out,</span> <span class="pre">+Mat]</span></code>, <code class="docutils literal"><span class="pre">Flow[-In,</span> <span class="pre">+Out,</span> <span class="pre">+Mat]</span></code> and <code class="docutils literal"><span class="pre">Sink[-In,</span> <span class="pre">+Mat]</span></code>?
They represent the type of values these processing parts return when materialized. When you chain these together,
you can explicitly combine their materialized values. In our example we used the <code class="docutils literal"><span class="pre">Keep.right</span></code> predefined function,
which tells the implementation to only care about the materialized type of the stage currently appended to the right.
The materialized type of <code class="docutils literal"><span class="pre">sumSink</span></code> is <code class="docutils literal"><span class="pre">Future[Int]</span></code> and because of using <code class="docutils literal"><span class="pre">Keep.right</span></code>, the resulting <code class="xref py py-class docutils literal"><span class="pre">RunnableGraph</span></code>
has also a type parameter of <code class="docutils literal"><span class="pre">Future[Int]</span></code>.</p>
<p>This step does <em>not</em> yet materialize the
processing pipeline, it merely prepares the description of the Flow, which is now connected to a Sink, and therefore can
be <code class="docutils literal"><span class="pre">run()</span></code>, as indicated by its type: <code class="docutils literal"><span class="pre">RunnableGraph[Future[Int]]</span></code>. Next we call <code class="docutils literal"><span class="pre">run()</span></code> which uses the implicit <code class="xref py py-class docutils literal"><span class="pre">ActorMaterializer</span></code>
to materialize and run the Flow. The value returned by calling <code class="docutils literal"><span class="pre">run()</span></code> on a <code class="docutils literal"><span class="pre">RunnableGraph[T]</span></code> is of type <code class="docutils literal"><span class="pre">T</span></code>.
In our case this type is <code class="docutils literal"><span class="pre">Future[Int]</span></code> which, when completed, will contain the total length of our <code class="docutils literal"><span class="pre">tweets</span></code> stream.
In case of the stream failing, this future would complete with a Failure.</p>
<p>A <code class="xref py py-class docutils literal"><span class="pre">RunnableGraph</span></code> may be reused
and materialized multiple times, because it is just the &quot;blueprint&quot; of the stream. This means that if we materialize a stream,
for example one that consumes a live stream of tweets within a minute, the materialized values for those two materializations
will be different, as illustrated by this example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">sumSink</span> <span class="k">=</span> <span class="nc">Sink</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">](</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="k">val</span> <span class="n">counterRunnableGraph</span><span class="k">:</span> <span class="kt">RunnableGraph</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">tweetsInMinuteFromNow</span>
    <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">hashtags</span> <span class="n">contains</span> <span class="n">akka</span><span class="o">)</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">t</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">toMat</span><span class="o">(</span><span class="n">sumSink</span><span class="o">)(</span><span class="nc">Keep</span><span class="o">.</span><span class="n">right</span><span class="o">)</span>

<span class="c1">// materialize the stream once in the morning</span>
<span class="k">val</span> <span class="n">morningTweetsCount</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">counterRunnableGraph</span><span class="o">.</span><span class="n">run</span><span class="o">()</span>
<span class="c1">// and once in the evening, reusing the flow</span>
<span class="k">val</span> <span class="n">eveningTweetsCount</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">counterRunnableGraph</span><span class="o">.</span><span class="n">run</span><span class="o">()</span>
</pre></div>
</div>
<p>Many elements in Akka Streams provide materialized values which can be used for obtaining either results of computation or
steering these elements which will be discussed in detail in <a class="reference internal" href="stream-flows-and-basics.html#stream-materialization-scala"><span class="std std-ref">Stream Materialization</span></a>. Summing up this section, now we know
what happens behind the scenes when we run this one-liner, which is equivalent to the multi line version above:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">tweets</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">t</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="o">).</span><span class="n">runWith</span><span class="o">(</span><span class="n">sumSink</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">runWith()</span></code> is a convenience method that automatically ignores the materialized value of any other stages except
those appended by the <code class="docutils literal"><span class="pre">runWith()</span></code> itself. In the above example it translates to using <code class="docutils literal"><span class="pre">Keep.right</span></code> as the combiner
for materialized values.</p>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: 10月 15, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>