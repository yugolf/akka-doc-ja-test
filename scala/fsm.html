

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>FSM &#8212; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '@version@',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Actors" href="index-actors.html" />
    <link rel="next" title="Persistence" href="persistence.html" />
    <link rel="prev" title="Routing" href="routing.html" />


  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">FSM</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="persistence.html">Persistence</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="routing.html">Routing</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version @version@
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="fsm">
<span id="fsm-scala"></span><h1>FSM</h1>
<div class="section" id="overview">
<h2>Overview</h2>
<p>The FSM (Finite State Machine) is available as a mixin for the Akka Actor and
is best described in the <a class="reference external" href="http://www.erlang.org/documentation/doc-4.8.2/doc/design_principles/fsm.html">Erlang design principles</a></p>
<p>A FSM can be described as a set of relations of the form:</p>
<blockquote>
<div><strong>State(S) x Event(E) -&gt; Actions (A), State(S')</strong></div></blockquote>
<p>These relations are interpreted as meaning:</p>
<blockquote>
<div><em>If we are in state S and the event E occurs, we should perform the actions A
and make a transition to the state S'.</em></div></blockquote>
</div>
<div class="section" id="a-simple-example">
<h2>A Simple Example</h2>
<p>To demonstrate most of the features of the <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait, consider an
actor which shall receive and queue messages while they arrive in a burst and
send them on after the burst ended or a flush request is received.</p>
<p>First, consider all of the below to use these import statements:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">ActorRef</span><span class="o">,</span> <span class="nc">FSM</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
</pre></div>
</div>
<p>The contract of our “Buncher” actor is that it accepts or produces the following messages:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// received events</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SetTarget</span><span class="o">(</span><span class="n">ref</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Flush</span>

<span class="c1">// sent events</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Batch</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SetTarget</span></code> is needed for starting it up, setting the destination for the
<code class="docutils literal"><span class="pre">Batches</span></code> to be passed on; <code class="docutils literal"><span class="pre">Queue</span></code> will add to the internal queue while
<code class="docutils literal"><span class="pre">Flush</span></code> will mark the end of a burst.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// states</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">State</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Idle</span> <span class="k">extends</span> <span class="nc">State</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Active</span> <span class="k">extends</span> <span class="nc">State</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Data</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Uninitialized</span> <span class="k">extends</span> <span class="nc">Data</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Todo</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">queue</span><span class="k">:</span> <span class="kt">immutable.Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Data</span>
</pre></div>
</div>
<p>The actor can be in two states: no message queued (aka <code class="docutils literal"><span class="pre">Idle</span></code>) or some
message queued (aka <code class="docutils literal"><span class="pre">Active</span></code>). It will stay in the active state as long as
messages keep arriving and no flush is requested. The internal state data of
the actor is made up of the target actor reference to send the batches to and
the actual queue of messages.</p>
<p>Now let’s take a look at the skeleton for our FSM actor:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Buncher</span> <span class="k">extends</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Data</span><span class="o">]</span> <span class="o">{</span>

  <span class="n">startWith</span><span class="o">(</span><span class="nc">Idle</span><span class="o">,</span> <span class="nc">Uninitialized</span><span class="o">)</span>

  <span class="n">when</span><span class="o">(</span><span class="nc">Idle</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">SetTarget</span><span class="o">(</span><span class="n">ref</span><span class="o">),</span> <span class="nc">Uninitialized</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">stay</span> <span class="n">using</span> <span class="nc">Todo</span><span class="o">(</span><span class="n">ref</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// transition elided ...</span>

  <span class="n">when</span><span class="o">(</span><span class="nc">Active</span><span class="o">,</span> <span class="n">stateTimeout</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Flush</span> <span class="o">|</span> <span class="nc">StateTimeout</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Todo</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">goto</span><span class="o">(</span><span class="nc">Idle</span><span class="o">)</span> <span class="n">using</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">queue</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// unhandled elided ...</span>

  <span class="n">initialize</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The basic strategy is to declare the actor, mixing in the <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait
and specifying the possible states and data values as type parameters. Within
the body of the actor a DSL is used for declaring the state machine:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">startWith</span></code> defines the initial state and initial data</li>
<li>then there is one <code class="xref py py-meth docutils literal"><span class="pre">when(&lt;state&gt;)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> declaration per state to be
handled (could potentially be multiple ones, the passed
<code class="xref py py-class docutils literal"><span class="pre">PartialFunction</span></code> will be concatenated using <code class="xref py py-meth docutils literal"><span class="pre">orElse</span></code>)</li>
<li>finally starting it up using <code class="xref py py-meth docutils literal"><span class="pre">initialize</span></code>, which performs the
transition into the initial state and sets up timers (if required).</li>
</ul>
</div></blockquote>
<p>In this case, we start out in the <code class="docutils literal"><span class="pre">Idle</span></code> and <code class="docutils literal"><span class="pre">Uninitialized</span></code> state, where
only the <code class="docutils literal"><span class="pre">SetTarget()</span></code> message is handled; <code class="docutils literal"><span class="pre">stay</span></code> prepares to end this
event’s processing for not leaving the current state, while the <code class="docutils literal"><span class="pre">using</span></code>
modifier makes the FSM replace the internal state (which is <code class="docutils literal"><span class="pre">Uninitialized</span></code>
at this point) with a fresh <code class="docutils literal"><span class="pre">Todo()</span></code> object containing the target actor
reference. The <code class="docutils literal"><span class="pre">Active</span></code> state has a state timeout declared, which means that
if no message is received for 1 second, a <code class="docutils literal"><span class="pre">FSM.StateTimeout</span></code> message will be
generated. This has the same effect as receiving the <code class="docutils literal"><span class="pre">Flush</span></code> command in this
case, namely to transition back into the <code class="docutils literal"><span class="pre">Idle</span></code> state and resetting the
internal queue to the empty vector. But how do messages get queued? Since this
shall work identically in both states, we make use of the fact that any event
which is not handled by the <code class="docutils literal"><span class="pre">when()</span></code> block is passed to the
<code class="docutils literal"><span class="pre">whenUnhandled()</span></code> block:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">whenUnhandled</span> <span class="o">{</span>
  <span class="c1">// common code for both states</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Queue</span><span class="o">(</span><span class="n">obj</span><span class="o">),</span> <span class="n">t</span> <span class="k">@</span> <span class="nc">Todo</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Active</span><span class="o">)</span> <span class="n">using</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">queue</span> <span class="k">=</span> <span class="n">v</span> <span class="o">:+</span> <span class="n">obj</span><span class="o">)</span>

  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">&quot;received unhandled request {} in state {}/{}&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">stateName</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
    <span class="n">stay</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The first case handled here is adding <code class="docutils literal"><span class="pre">Queue()</span></code> requests to the internal
queue and going to the <code class="docutils literal"><span class="pre">Active</span></code> state (this does the obvious thing of staying
in the <code class="docutils literal"><span class="pre">Active</span></code> state if already there), but only if the FSM data are not
<code class="docutils literal"><span class="pre">Uninitialized</span></code> when the <code class="docutils literal"><span class="pre">Queue()</span></code> event is received. Otherwise—and in all
other non-handled cases—the second case just logs a warning and does not change
the internal state.</p>
<p>The only missing piece is where the <code class="docutils literal"><span class="pre">Batches</span></code> are actually sent to the
target, for which we use the <code class="docutils literal"><span class="pre">onTransition</span></code> mechanism: you can declare
multiple such blocks and all of them will be tried for matching behavior in
case a state transition occurs (i.e. only when the state actually changes).</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">onTransition</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Active</span> <span class="o">-&gt;</span> <span class="nc">Idle</span> <span class="k">=&gt;</span>
    <span class="n">stateData</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Todo</span><span class="o">(</span><span class="n">ref</span><span class="o">,</span> <span class="n">queue</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ref</span> <span class="o">!</span> <span class="nc">Batch</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span>
      <span class="k">case</span> <span class="k">_</span>                <span class="k">=&gt;</span> <span class="c1">// nothing to do</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The transition callback is a partial function which takes as input a pair of
states—the current and the next state. The FSM trait includes a convenience
extractor for these in form of an arrow operator, which conveniently reminds
you of the direction of the state change which is being matched. During the
state change, the old state data is available via <code class="docutils literal"><span class="pre">stateData</span></code> as shown, and
the new state data would be available as <code class="docutils literal"><span class="pre">nextStateData</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Same-state transitions can be implemented (when currently in state <code class="docutils literal"><span class="pre">S</span></code>) using
<code class="docutils literal"><span class="pre">goto(S)</span></code> or <code class="docutils literal"><span class="pre">stay()</span></code>. The difference between those being that <code class="docutils literal"><span class="pre">goto(S)</span></code> will
emit an event <code class="docutils literal"><span class="pre">S-&gt;S</span></code> event that can be handled by <code class="docutils literal"><span class="pre">onTransition</span></code>,
whereas <code class="docutils literal"><span class="pre">stay()</span></code> will <em>not</em>.</p>
</div>
<p>To verify that this buncher actually works, it is quite easy to write a test
using the <a class="reference internal" href="testing.html#akka-testkit"><span class="std std-ref">Testing Actor Systems</span></a>, which is conveniently bundled with ScalaTest traits
into <code class="docutils literal"><span class="pre">AkkaSpec</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable</span>

<span class="k">object</span> <span class="nc">FSMDocSpec</span> <span class="o">{</span>
  <span class="c1">// messages and data types</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">FSMDocSpec</span> <span class="k">extends</span> <span class="nc">MyFavoriteTestFrameWorkPlusAkkaTestKit</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">FSMDocSpec._</span>

  <span class="c1">// fsm code elided ...</span>

  <span class="s">&quot;simple finite state machine&quot;</span> <span class="n">must</span> <span class="o">{</span>

    <span class="s">&quot;demonstrate NullFunction&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Null</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nc">SomeState</span> <span class="k">=</span> <span class="mi">0</span>
        <span class="n">when</span><span class="o">(</span><span class="nc">SomeState</span><span class="o">)(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">NullFunction</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="s">&quot;batch correctly&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">buncher</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Buncher</span><span class="o">],</span> <span class="k">this</span><span class="o">))</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">SetTarget</span><span class="o">(</span><span class="n">testActor</span><span class="o">)</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">43</span><span class="o">)</span>
      <span class="n">expectMsg</span><span class="o">(</span><span class="nc">Batch</span><span class="o">(</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">43</span><span class="o">)))</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">44</span><span class="o">)</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Flush</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">45</span><span class="o">)</span>
      <span class="n">expectMsg</span><span class="o">(</span><span class="nc">Batch</span><span class="o">(</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">44</span><span class="o">)))</span>
      <span class="n">expectMsg</span><span class="o">(</span><span class="nc">Batch</span><span class="o">(</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">45</span><span class="o">)))</span>
    <span class="o">}</span>

    <span class="s">&quot;not batch if uninitialized&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">buncher</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Buncher</span><span class="o">],</span> <span class="k">this</span><span class="o">))</span>
      <span class="n">buncher</span> <span class="o">!</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
      <span class="n">expectNoMsg</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reference">
<h2>Reference</h2>
<div class="section" id="the-fsm-trait-and-object">
<h3>The FSM Trait and Object</h3>
<p>The <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait inherits directly from <code class="xref py py-class docutils literal"><span class="pre">Actor</span></code>, when you
extend <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> you must be aware that an actor is actually created:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Buncher</span> <span class="k">extends</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">Data</span><span class="o">]</span> <span class="o">{</span>

  <span class="c1">// fsm body ...</span>

  <span class="n">initialize</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The FSM trait defines a <code class="docutils literal"><span class="pre">receive</span></code> method which handles internal messages
and passes everything else through to the FSM logic (according to the
current state). When overriding the <code class="docutils literal"><span class="pre">receive</span></code> method, keep in mind that
e.g. state timeout handling depends on actually passing the messages through
the FSM logic.</p>
</div>
<p>The <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait takes two type parameters:</p>
<blockquote>
<div><ol class="arabic simple">
<li>the supertype of all state names, usually a sealed trait with case objects
extending it,</li>
<li>the type of the state data which are tracked by the <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> module
itself.</li>
</ol>
</div></blockquote>
<div class="admonition note" id="fsm-philosophy">
<p class="first admonition-title">注釈</p>
<p class="last">The state data together with the state name describe the internal state of
the state machine; if you stick to this scheme and do not add mutable fields
to the FSM class you have the advantage of making all changes of the
internal state explicit in a few well-known places.</p>
</div>
</div>
<div class="section" id="defining-states">
<h3>Defining States</h3>
<p>A state is defined by one or more invocations of the method</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">when(&lt;name&gt;[,&nbsp;stateTimeout&nbsp;=&nbsp;&lt;timeout&gt;])(stateFunction)</span></code>.</div></blockquote>
<p>The given name must be an object which is type-compatible with the first type
parameter given to the <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait. This object is used as a hash key,
so you must ensure that it properly implements <code class="xref py py-meth docutils literal"><span class="pre">equals</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">hashCode</span></code>; in particular it must not be mutable. The easiest fit for
these requirements are case objects.</p>
<p>If the <code class="xref py py-meth docutils literal"><span class="pre">stateTimeout</span></code> parameter is given, then all transitions into this
state, including staying, receive this timeout by default. Initiating the
transition with an explicit timeout may be used to override this default, see
<a class="reference internal" href="#initiating-transitions">Initiating Transitions</a> for more information. The state timeout of any state
may be changed during action processing with
<code class="xref py py-func docutils literal"><span class="pre">setStateTimeout(state,&nbsp;duration)</span></code>. This enables runtime configuration
e.g. via external message.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">stateFunction</span></code> argument is a <code class="xref py py-class docutils literal"><span class="pre">PartialFunction[Event,&nbsp;State]</span></code>,
which is conveniently given using the partial function literal syntax as
demonstrated below:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">when</span><span class="o">(</span><span class="nc">Idle</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">SetTarget</span><span class="o">(</span><span class="n">ref</span><span class="o">),</span> <span class="nc">Uninitialized</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">stay</span> <span class="n">using</span> <span class="nc">Todo</span><span class="o">(</span><span class="n">ref</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">when</span><span class="o">(</span><span class="nc">Active</span><span class="o">,</span> <span class="n">stateTimeout</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="nc">Flush</span> <span class="o">|</span> <span class="nc">StateTimeout</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Todo</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Idle</span><span class="o">)</span> <span class="n">using</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">queue</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal"><span class="pre">Event(msg:&nbsp;Any,&nbsp;data:&nbsp;D)</span></code> case class is parameterized with the data
type held by the FSM for convenient pattern matching.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">It is required that you define handlers for each of the possible FSM states,
otherwise there will be failures when trying to switch to undeclared states.</p>
</div>
<p>It is recommended practice to declare the states as objects extending a
sealed trait and then verify that there is a <code class="docutils literal"><span class="pre">when</span></code> clause for each of the
states. If you want to leave the handling of a state “unhandled” (more below),
it still needs to be declared like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">when</span><span class="o">(</span><span class="nc">SomeState</span><span class="o">)(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">NullFunction</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-the-initial-state">
<h3>Defining the Initial State</h3>
<p>Each FSM needs a starting point, which is declared using</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">startWith(state,&nbsp;data[,&nbsp;timeout])</span></code></div></blockquote>
<p>The optionally given timeout argument overrides any specification given for the
desired initial state. If you want to cancel a default timeout, use
<code class="xref py py-obj docutils literal"><span class="pre">None</span></code>.</p>
</div>
<div class="section" id="unhandled-events">
<h3>Unhandled Events</h3>
<p>If a state doesn't handle a received event a warning is logged. If you want to
do something else in this case you can specify that with
<code class="xref py py-func docutils literal"><span class="pre">whenUnhandled(stateFunction)</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">whenUnhandled</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Received unhandled event: &quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
    <span class="n">stay</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">&quot;Received unknown event: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Error</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Within this handler the state of the FSM may be queried using the
<code class="xref py py-meth docutils literal"><span class="pre">stateName</span></code> method.</p>
<p><strong>IMPORTANT</strong>: This handler is not stacked, meaning that each invocation of
<code class="xref py py-func docutils literal"><span class="pre">whenUnhandled</span></code> replaces the previously installed handler.</p>
</div>
<div class="section" id="initiating-transitions">
<h3>Initiating Transitions</h3>
<p>The result of any <code class="xref py py-obj docutils literal"><span class="pre">stateFunction</span></code> must be a definition of the next state
unless terminating the FSM, which is described in <a class="reference internal" href="#termination-from-inside">Termination from Inside</a>.
The state definition can either be the current state, as described by the
<code class="xref py py-func docutils literal"><span class="pre">stay</span></code> directive, or it is a different state as given by
<code class="xref py py-func docutils literal"><span class="pre">goto(state)</span></code>. The resulting object allows further qualification by way
of the modifiers described in the following:</p>
<ul>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">forMax(duration)</span></code></p>
<p>This modifier sets a state timeout on the next state. This means that a timer
is started which upon expiry sends a <code class="xref py py-obj docutils literal"><span class="pre">StateTimeout</span></code> message to the FSM.
This timer is canceled upon reception of any other message in the meantime;
you can rely on the fact that the <code class="xref py py-obj docutils literal"><span class="pre">StateTimeout</span></code> message will not be
processed after an intervening message.</p>
<p>This modifier can also be used to override any default timeout which is
specified for the target state. If you want to cancel the default timeout,
use <code class="xref py py-obj docutils literal"><span class="pre">Duration.Inf</span></code>.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">using(data)</span></code></p>
<p>This modifier replaces the old state data with the new data given. If you
follow the advice <a class="reference internal" href="#fsm-philosophy"><span class="std std-ref">above</span></a>, this is the only place where
internal state data are ever modified.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">replying(msg)</span></code></p>
<p>This modifier sends a reply to the currently processed message and otherwise
does not modify the state transition.</p>
</li>
</ul>
<p>All modifiers can be chained to achieve a nice and concise description:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">when</span><span class="o">(</span><span class="nc">SomeState</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Processing</span><span class="o">)</span> <span class="n">using</span> <span class="o">(</span><span class="n">newData</span><span class="o">)</span> <span class="n">forMax</span> <span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span> <span class="n">replying</span> <span class="o">(</span><span class="nc">WillDo</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The parentheses are not actually needed in all cases, but they visually
distinguish between modifiers and their arguments and therefore make the code
even more pleasant to read for foreigners.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Please note that the <code class="docutils literal"><span class="pre">return</span></code> statement may not be used in <code class="xref py py-meth docutils literal"><span class="pre">when</span></code>
blocks or similar; this is a Scala restriction. Either refactor your code
using <code class="docutils literal"><span class="pre">if&nbsp;()&nbsp;...&nbsp;else&nbsp;...</span></code> or move it into a method definition.</p>
</div>
</div>
<div class="section" id="monitoring-transitions">
<h3>Monitoring Transitions</h3>
<p>Transitions occur &quot;between states&quot; conceptually, which means after any actions
you have put into the event handling block; this is obvious since the next
state is only defined by the value returned by the event handling logic. You do
not need to worry about the exact order with respect to setting the internal
state variable, as everything within the FSM actor is running single-threaded
anyway.</p>
<div class="section" id="internal-monitoring">
<h4>Internal Monitoring</h4>
<p>Up to this point, the FSM DSL has been centered on states and events. The dual
view is to describe it as a series of transitions. This is enabled by the
method</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">onTransition(handler)</span></code></div></blockquote>
<p>which associates actions with a transition instead of with a state and event.
The handler is a partial function which takes a pair of states as input; no
resulting state is needed as it is not possible to modify the transition in
progress.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">onTransition</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Idle</span> <span class="o">-&gt;</span> <span class="nc">Active</span> <span class="k">=&gt;</span> <span class="n">setTimer</span><span class="o">(</span><span class="s">&quot;timeout&quot;</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">,</span> <span class="mi">1</span> <span class="n">second</span><span class="o">,</span> <span class="n">repeat</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Active</span> <span class="o">-&gt;</span> <span class="k">_</span>    <span class="k">=&gt;</span> <span class="n">cancelTimer</span><span class="o">(</span><span class="s">&quot;timeout&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">Idle</span>      <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;entering Idle from &quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The convenience extractor <code class="xref py py-obj docutils literal"><span class="pre">-&gt;</span></code> enables decomposition of the pair of states
with a clear visual reminder of the transition's direction. As usual in pattern
matches, an underscore may be used for irrelevant parts; alternatively you
could bind the unconstrained state to a variable, e.g. for logging as shown in
the last case.</p>
<p>It is also possible to pass a function object accepting two states to
<code class="xref py py-func docutils literal"><span class="pre">onTransition</span></code>, in case your transition handling logic is implemented as
a method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">onTransition</span><span class="o">(</span><span class="n">handler</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="n">handler</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">StateType</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">StateType</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// handle it here ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The handlers registered with this method are stacked, so you can intersperse
<code class="xref py py-func docutils literal"><span class="pre">onTransition</span></code> blocks with <code class="xref py py-func docutils literal"><span class="pre">when</span></code> blocks as suits your design. It
should be noted, however, that <em>all handlers will be invoked for each
transition</em>, not only the first matching one. This is designed specifically so
you can put all transition handling for a certain aspect into one place without
having to worry about earlier declarations shadowing later ones; the actions
are still executed in declaration order, though.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This kind of internal monitoring may be used to structure your FSM according
to transitions, so that for example the cancellation of a timer upon leaving
a certain state cannot be forgot when adding new target states.</p>
</div>
</div>
<div class="section" id="external-monitoring">
<h4>External Monitoring</h4>
<p>External actors may be registered to be notified of state transitions by
sending a message <code class="xref py py-class docutils literal"><span class="pre">SubscribeTransitionCallBack(actorRef)</span></code>. The named
actor will be sent a <code class="xref py py-class docutils literal"><span class="pre">CurrentState(self,&nbsp;stateName)</span></code> message immediately
and will receive <code class="xref py py-class docutils literal"><span class="pre">Transition(actorRef,&nbsp;oldState,&nbsp;newState)</span></code> messages
whenever a state change is triggered.</p>
<p>Please note that a state change includes the action of performing an <code class="docutils literal"><span class="pre">goto(S)</span></code>, while
already being state <code class="docutils literal"><span class="pre">S</span></code>. In that case the monitoring actor will be notified with an
<code class="docutils literal"><span class="pre">Transition(ref,S,S)</span></code> message. This may be useful if your <code class="docutils literal"><span class="pre">FSM</span></code> should
react on all (also same-state) transitions. In case you'd rather not emit events for same-state
transitions use <code class="docutils literal"><span class="pre">stay()</span></code> instead of <code class="docutils literal"><span class="pre">goto(S)</span></code>.</p>
<p>External monitors may be unregistered by sending
<code class="xref py py-class docutils literal"><span class="pre">UnsubscribeTransitionCallBack(actorRef)</span></code> to the <code class="docutils literal"><span class="pre">FSM</span></code> actor.</p>
<p>Stopping a listener without unregistering will not remove the listener from the
subscription list; use <code class="xref py py-class docutils literal"><span class="pre">UnsubscribeTransitionCallback</span></code> before stopping
the listener.</p>
</div>
</div>
<div class="section" id="transforming-state">
<h3>Transforming State</h3>
<p>The partial functions supplied as argument to the <code class="docutils literal"><span class="pre">when()</span></code> blocks can be
transformed using Scala’s full supplement of functional programming tools. In
order to retain type inference, there is a helper function which may be used in
case some common handling logic shall be applied to different clauses:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">when</span><span class="o">(</span><span class="nc">SomeState</span><span class="o">)(</span><span class="n">transform</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">ByteString</span><span class="o">,</span> <span class="n">read</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">stay</span> <span class="n">using</span> <span class="o">(</span><span class="n">read</span> <span class="o">+</span> <span class="n">bytes</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="o">}</span> <span class="n">using</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">FSM</span><span class="o">.</span><span class="nc">State</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">read</span><span class="o">,</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">stopReason</span><span class="o">,</span> <span class="n">replies</span><span class="o">)</span> <span class="k">if</span> <span class="n">read</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="k">=&gt;</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Processing</span><span class="o">)</span>
<span class="o">})</span>
</pre></div>
</div>
<p>It goes without saying that the arguments to this method may also be stored, to
be used several times, e.g. when applying the same transformation to several
<code class="docutils literal"><span class="pre">when()</span></code> blocks:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">processingTrigger</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">State</span>, <span class="kt">State</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">FSM</span><span class="o">.</span><span class="nc">State</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">read</span><span class="o">,</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">stopReason</span><span class="o">,</span> <span class="n">replies</span><span class="o">)</span> <span class="k">if</span> <span class="n">read</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="k">=&gt;</span>
    <span class="n">goto</span><span class="o">(</span><span class="nc">Processing</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">when</span><span class="o">(</span><span class="nc">SomeState</span><span class="o">)(</span><span class="n">transform</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">ByteString</span><span class="o">,</span> <span class="n">read</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">stay</span> <span class="n">using</span> <span class="o">(</span><span class="n">read</span> <span class="o">+</span> <span class="n">bytes</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="o">}</span> <span class="n">using</span> <span class="n">processingTrigger</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="timers">
<h3>Timers</h3>
<p>Besides state timeouts, FSM manages timers identified by <code class="xref py py-class docutils literal"><span class="pre">String</span></code> names.
You may set a timer using</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">setTimer(name,&nbsp;msg,&nbsp;interval,&nbsp;repeat)</span></code></div></blockquote>
<p>where <code class="xref py py-obj docutils literal"><span class="pre">msg</span></code> is the message object which will be sent after the duration
<code class="xref py py-obj docutils literal"><span class="pre">interval</span></code> has elapsed. If <code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code> is <code class="xref py py-obj docutils literal"><span class="pre">true</span></code>, then the timer is
scheduled at fixed rate given by the <code class="xref py py-obj docutils literal"><span class="pre">interval</span></code> parameter.
Any existing timer with the same name will automatically be canceled before
adding the new timer.</p>
<p>Timers may be canceled using</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">cancelTimer(name)</span></code></div></blockquote>
<p>which is guaranteed to work immediately, meaning that the scheduled message
will not be processed after this call even if the timer already fired and
queued it. The status of any timer may be inquired with</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">isTimerActive(name)</span></code></div></blockquote>
<p>These named timers complement state timeouts because they are not affected by
intervening reception of other messages.</p>
</div>
<div class="section" id="termination-from-inside">
<h3>Termination from Inside</h3>
<p>The FSM is stopped by specifying the result state as</p>
<blockquote>
<div><code class="xref py py-func docutils literal"><span class="pre">stop([reason[,&nbsp;data]])</span></code></div></blockquote>
<p>The reason must be one of <code class="xref py py-obj docutils literal"><span class="pre">Normal</span></code> (which is the default), <code class="xref py py-obj docutils literal"><span class="pre">Shutdown</span></code>
or <code class="xref py py-obj docutils literal"><span class="pre">Failure(reason)</span></code>, and the second argument may be given to change the
state data which is available during termination handling.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">It should be noted that <code class="xref py py-func docutils literal"><span class="pre">stop</span></code> does not abort the actions and stop the
FSM immediately. The stop action must be returned from the event handler in
the same way as a state transition (but note that the <code class="docutils literal"><span class="pre">return</span></code> statement
may not be used within a <code class="xref py py-meth docutils literal"><span class="pre">when</span></code> block).</p>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">when</span><span class="o">(</span><span class="nc">Error</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="s">&quot;stop&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// do cleanup ...</span>
    <span class="n">stop</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can use <code class="xref py py-func docutils literal"><span class="pre">onTermination(handler)</span></code> to specify custom code that is
executed when the FSM is stopped. The handler is a partial function which takes
a <code class="xref py py-class docutils literal"><span class="pre">StopEvent(reason,&nbsp;stateName,&nbsp;stateData)</span></code> as argument:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">onTermination</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">StopEvent</span><span class="o">(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">Normal</span><span class="o">,</span> <span class="n">state</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span>         <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="k">case</span> <span class="nc">StopEvent</span><span class="o">(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">Shutdown</span><span class="o">,</span> <span class="n">state</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span>       <span class="k">=&gt;</span> <span class="c1">// ...</span>
  <span class="k">case</span> <span class="nc">StopEvent</span><span class="o">(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="n">cause</span><span class="o">),</span> <span class="n">state</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>As for the <code class="xref py py-func docutils literal"><span class="pre">whenUnhandled</span></code> case, this handler is not stacked, so each
invocation of <code class="xref py py-func docutils literal"><span class="pre">onTermination</span></code> replaces the previously installed handler.</p>
</div>
<div class="section" id="termination-from-outside">
<h3>Termination from Outside</h3>
<p>When an <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> associated to a FSM is stopped using the
<code class="xref py py-meth docutils literal"><span class="pre">stop</span></code> method, its <code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code> hook will be executed. The default
implementation by the <code class="xref py py-class docutils literal"><span class="pre">FSM</span></code> trait is to execute the
<code class="xref py py-meth docutils literal"><span class="pre">onTermination</span></code> handler if that is prepared to handle a
<code class="xref py py-obj docutils literal"><span class="pre">StopEvent(Shutdown,&nbsp;...)</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">In case you override <code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code> and want to have your
<code class="xref py py-meth docutils literal"><span class="pre">onTermination</span></code> handler called, do not forget to call
<code class="docutils literal"><span class="pre">super.postStop</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="testing-and-debugging-finite-state-machines">
<h2>Testing and Debugging Finite State Machines</h2>
<p>During development and for trouble shooting FSMs need care just as any other
actor. There are specialized tools available as described in <a class="reference internal" href="testing.html#testfsmref"><span class="std std-ref">Testing Finite State Machines</span></a>
and in the following.</p>
<div class="section" id="event-tracing">
<h3>Event Tracing</h3>
<p>The setting <code class="docutils literal"><span class="pre">akka.actor.debug.fsm</span></code> in <a class="reference internal" href="../general/configuration.html#configuration"><span class="std std-ref">Configuration</span></a> enables logging of an
event trace by <code class="xref py py-class docutils literal"><span class="pre">LoggingFSM</span></code> instances:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.LoggingFSM</span>
<span class="k">class</span> <span class="nc">MyFSM</span> <span class="k">extends</span> <span class="nc">LoggingFSM</span><span class="o">[</span><span class="kt">StateType</span>, <span class="kt">Data</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// body elided ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This FSM will log at DEBUG level:</p>
<blockquote>
<div><ul class="simple">
<li>all processed events, including <code class="xref py py-obj docutils literal"><span class="pre">StateTimeout</span></code> and scheduled timer
messages</li>
<li>every setting and cancellation of named timers</li>
<li>all state transitions</li>
</ul>
</div></blockquote>
<p>Life cycle changes and special messages can be logged as described for
<a class="reference internal" href="testing.html#actor-logging-scala"><span class="std std-ref">Actors</span></a>.</p>
</div>
<div class="section" id="rolling-event-log">
<h3>Rolling Event Log</h3>
<p>The <code class="xref py py-class docutils literal"><span class="pre">LoggingFSM</span></code> trait adds one more feature to the FSM: a rolling event
log which may be used during debugging (for tracing how the FSM entered a
certain failure state) or for other creative uses:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.LoggingFSM</span>
<span class="k">class</span> <span class="nc">MyFSM</span> <span class="k">extends</span> <span class="nc">LoggingFSM</span><span class="o">[</span><span class="kt">StateType</span>, <span class="kt">Data</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">logDepth</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="n">onTermination</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">StopEvent</span><span class="o">(</span><span class="nc">FSM</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="n">state</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">lastEvents</span> <span class="k">=</span> <span class="n">getLog</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n\t&quot;</span><span class="o">)</span>
      <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">&quot;Failure in state &quot;</span> <span class="o">+</span> <span class="n">state</span> <span class="o">+</span> <span class="s">&quot; with data &quot;</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span> <span class="o">+</span>
        <span class="s">&quot;Events leading up to this point:\n\t&quot;</span> <span class="o">+</span> <span class="n">lastEvents</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">logDepth</span></code> defaults to zero, which turns off the event log.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The log buffer is allocated during actor creation, which is why the
configuration is done using a virtual method call. If you want to override
with a <code class="docutils literal"><span class="pre">val</span></code>, make sure that its initialization happens before the
initializer of <code class="xref py py-class docutils literal"><span class="pre">LoggingFSM</span></code> runs, and do not change the value returned
by <code class="docutils literal"><span class="pre">logDepth</span></code> after the buffer has been allocated.</p>
</div>
<p>The contents of the event log are available using method <code class="xref py py-meth docutils literal"><span class="pre">getLog</span></code>, which
returns an <code class="xref py py-class docutils literal"><span class="pre">IndexedSeq[LogEntry]</span></code> where the oldest entry is at index
zero.</p>
</div>
</div>
<div class="section" id="examples">
<h2>Examples</h2>
<p>A bigger FSM example contrasted with Actor's <code class="xref py py-meth docutils literal"><span class="pre">become</span></code>/<code class="xref py py-meth docutils literal"><span class="pre">unbecome</span></code> can be found in
the <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a> template named
<a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-fsm-scala">Akka FSM in Scala</a></p>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: 10月 15, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>