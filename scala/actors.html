

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>アクター &#8212; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '@version@',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Actors" href="index-actors.html" />
    <link rel="next" title="Akka Typed" href="typed.html" />
    <link rel="prev" title="Actors" href="index-actors.html" />


  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">アクター</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">
              <li>
                 <span class="divider">|</span> <a href="typed.html">Akka Typed</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="index-actors.html">Actors</a> <span class="divider">|</span>
              </li>
              <li style="float: left">
                Version @version@
              </li>
              <li style="float: left">
                <input type="search" id="search" class="form-control" />
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="actors">
<span id="actors-scala"></span><h1>アクター</h1>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>アクターモデル`は並行分散システムを作るための高度な抽象を提供します。アクターモデルを用いることで開発者は明示的なロックやスレッドの管理を行う労力を軽減した上で信頼性のある並行並列なシステムを作ることができます。アクターは Cal Herwitt が1973年に論文として発表したものですが、Erlangによって世に広められ、この成功例として Ericsson 社による高い並行性と信頼性を持つ電気通信システムの構築が挙げられます。</p>
<p>Akka のアクターは Erlang からシンタックスを拝借した Scala のアクターと似ています。</p>
<div class="section" id="creating-actors">
<h2>アクターの生成</h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Akka では全てのアクターが親となるアクターに監視され、同時に子供のアクターの supervisor になる(可能性がある)という方式をとっています。この方式については <a class="reference internal" href="../general/actor-systems.html#actor-systems"><span class="std std-ref">Actor Systems</span></a> や <a class="reference internal" href="../general/supervision.html#supervision"><span class="std std-ref">Supervision and Monitoring</span></a> あるいは <a class="reference internal" href="../general/addressing.html#addressing"><span class="std std-ref">Actor References, Paths and Addresses</span></a> といった記事を参考に読んでみるとよいでしょう。</p>
</div>
<div class="section" id="defining-an-actor-class">
<h3>アクターのクラスを定義する</h3>
<p>アクターは:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor`という基本traitを拡張することで実装することができます。また、ここで:meth:<a href="#id3"><span class="problematic" id="id4">`</span></a>receive`というメソッドを実装する必要があります。:meth:<a href="#id5"><span class="problematic" id="id6">`</span></a>receive`というメソッドはcase文の塊で(この型は`PartialFunction[Any, Unit]``です)、Scalaのパターンマッチングを使ってアクターがどのようなメッセージを処理できるかということとそのメッセージがどのように処理されるかということを定義します。</p>
<p>以下はこのサンプルコードです。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;test&quot;</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received test&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span>      <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received unknown message&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Akkaのアクターの``receive``メッセージループは網羅的であるということに注意してください。これはErlangやScala言語組み込みのアクターとは異なっています。つまり受け取ることのできる全てのメッセージについてのパターンマッチを書く必要があり、未知のメッセージを処理したい場合はデフォルトのcaseを書かなければいけません。これを行わなかった場合は <a href="#id1"><span class="problematic" id="id2">``</span></a>ActorSystem``の``EventStream``に`akka.actor.UnhandledMessage(message, sender, recipient)``が発行されます。</p>
<p>また、振る舞いの戻り値の型が``Unit``であることにも注意してください。アクターが受け取ったメッセージに対して応答を返す場合、後で説明するようにこれを明示的に行う必要があります。</p>
<p>:meth:<a href="#id1"><span class="problematic" id="id2">`</span></a>receive`メソッドの結果は部分関数であり、アクターの&quot;初期の振る舞い&quot;とみなされます。アクターが生成された後でどのように振る舞いを変えるかということについての詳しい情報は`Become/Unbecome`_を参照してください。</p>
</div>
<div class="section" id="props">
<h3>Props</h3>
<p>:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Propsはアクターを生成するときのオプションを指定するための設定クラスです。このクラスのインスタンスは不変なので気軽に共有することができるアクターを生成するためのレシピと考えることができます。また、このレシピにはデプロイに関係した情報(例えばどのdispatcherを使うかとかいったもの)も含めることができます。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.Props</span>

<span class="k">val</span> <span class="n">props1</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="k">val</span> <span class="n">props2</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">ActorWithArgs</span><span class="o">(</span><span class="s">&quot;arg&quot;</span><span class="o">))</span> <span class="c1">// careful, see below</span>
<span class="k">val</span> <span class="n">props3</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ActorWithArgs</span><span class="o">],</span> <span class="s">&quot;arg&quot;</span><span class="o">)</span> <span class="c1">// no support for value class arguments</span>
</pre></div>
</div>
<p>二つ目のやり方は生成する:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor`にどのように引数を渡すかということを例示していますが、後で説明するように、アクターの外側のみで用いるべきやり方です。</p>
<p>最後のやり方はアクターのコンストラクタに引数を渡す場合にどのようなコンテクストでも使うことができるやり方です。Propsオブジェクトの中でどのコンストラクタを用いるべきかということを調べて、適当なコンストラクタが見つからなかった場合や複数のコンストラクタにマッチしてしまった場合には:class:<cite>IllegalArgumentException</cite> となってしまいます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">アクターのコンストラクタが引数として値クラスを受け取る場合、アクターの:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props`を作るための推奨される手法はサポートされていません。</p>
</div>
<div class="section" id="dangerous-variants">
<h4>危険な方法</h4>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// NOT RECOMMENDED within another actor:</span>
<span class="c1">// encourages to close over enclosing class</span>
<span class="k">val</span> <span class="n">props7</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyActor</span><span class="o">)</span>
</pre></div>
</div>
<p>このメソッドはアクターの中で使わないほうがいいです。このメソッドによって呼び出し元のアクターのスコープをリークしてしまい、:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props`が永続化不可になってしまい競合状態(アクターのカプセル化が壊されるということ)を引き起こす可能性があります。将来的にはマクロを使って同じようなシンタックスを使っても問題が起きないようにする予定ですが、現在のところこの方式は非推奨としたほうがいいでしょう。一方で、&quot;推奨される手法&quot;のところに書いてあるアクターのコンパニオンオブジェクトにある:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Props`のファクトリを使うというやり方は特に問題がありません。</p>
<p>このメソッドを使うユースケースは二つあります。一つはアクターのコンストラクタに引数を渡したい場合ですが、これは新しくできた:meth:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props.apply(clazz, args)`を上に書いてあるとおりに使うか下に書いてあるような推奨される手法を使うことで解決できます。もう一つは&quot;その場で&quot;無名のアクターを作る場合ですが、これはそのようなアクターにちゃんと名前を付けてあげることで解決できます。(アクターがトップレベルの``object``として宣言されていない場合、それに紐づくインスタンスの&quot;this&quot;の参照がクラスの最初の引数に渡されてしまいます)</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">あるアクターを別のアクターの中で宣言することは非常に危険でアクターのカプセル化を破壊してしまいます。アクターの&quot;this&quot;への参照を:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props`に渡してしまわないように注意してください。</p>
</div>
</div>
<div class="section" id="edge-cases">
<h4>エッジケース</h4>
<p>:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props`を使ったアクターの生成には二つのエッジケースがあります。</p>
<ul class="simple">
<li><p class="first">引数に:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>AnyVal`を受け取るアクター</p>
</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">MyValueClass</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ValueActor</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">MyValueClass</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">multiplier</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="n">multiplier</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">valueClassProp</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ValueActor</span><span class="o">],</span> <span class="nc">MyValueClass</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span> <span class="c1">// Unsupported</span>
</pre></div>
</div>
<ul class="simple">
<li><p class="first">デフォルトのコンストラクタ引数を持つアクター</p>
</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DefaultValueActor</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="o">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">defaultValueProp1</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">DefaultValueActor</span><span class="o">],</span> <span class="mf">2.0</span><span class="o">)</span> <span class="c1">// Unsupported</span>

<span class="k">class</span> <span class="nc">DefaultValueActor2</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">defaultValueProp2</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">DefaultValueActor2</span><span class="o">]</span> <span class="c1">// Unsupported</span>
<span class="k">val</span> <span class="n">defaultValueProp3</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">DefaultValueActor2</span><span class="o">])</span> <span class="c1">// Unsupported</span>
</pre></div>
</div>
<p>どちらのケースもコンストラクターを見つけられない状態になってしまって <code class="xref py py-class docutils literal"><span class="pre">IllegalArgumentException</span></code> がスローされます。</p>
<p>次のセクションでは:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor`のpropを作るための推奨される手法を説明します。同時にこの手法はこれらのエッジケースに対する回避策になります。</p>
</div>
<div class="section" id="recommended-practices">
<h4>推奨される手法</h4>
<p>全ての:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor`のコンパニオンオブジェクトの中で:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Props`の生成を適切に行うことを補助するようなファクトリメソッドを提供するのは良いアイディアです。コンパニオンオブジェクトの中のコードブロックはcall-by-nameなメソッド引数の中にリークしないので、こうしたファクトリメソッドを使えば``Props.apply(...)``を使うことによる落とし穴に嵌ることを避けることができます。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">DemoActor</span> <span class="o">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Create Props for an actor of this type.</span>
<span class="cm">   *</span>
<span class="cm">   * @param magicNumber The magic number to be passed to this actor’s constructor.</span>
<span class="cm">   * @return a Props for creating this actor, which can then be further configured</span>
<span class="cm">   *         (e.g. calling `.withDispatcher()` on it)</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">props</span><span class="o">(</span><span class="n">magicNumber</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Props</span> <span class="o">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">DemoActor</span><span class="o">(</span><span class="n">magicNumber</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">DemoActor</span><span class="o">(</span><span class="n">magicNumber</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">magicNumber</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">SomeOtherActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// Props(new DemoActor(42)) would not be safe</span>
  <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">DemoActor</span><span class="o">.</span><span class="n">props</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="s">&quot;demo&quot;</span><span class="o">)</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>もう一つの良い手法として、コンパニオンオブジェクトの中でそのアクターが受け取ることができるメッセージを宣言するというものがあります。このようにしておくと、アクターがどのようなメッセージを受け取ることができるのかがわかりやすくなります。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyActor</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Greeting</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Goodbye</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">MyActor._</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Greeting</span><span class="o">(</span><span class="n">greeter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">s&quot;I was greeted by </span><span class="si">$greeter</span><span class="s">.&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Goodbye</span>           <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Someone said goodbye to me.&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creating-actors-with-props">
<h3>Propsを使ったアクターの生成</h3>
<p>アクターは:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Props`のインスタンスを:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>ActorSystem`や:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>ActorContext`が持っている:meth:<a href="#id7"><span class="problematic" id="id8">`</span></a>actorOf`というファクトリメソッドに渡すことで生成できます。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>

<span class="c1">// ActorSystem is a heavy object: create only one per application</span>
<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;mySystem&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="s">&quot;myactor2&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>ActorSystem`を使うとトップレベルのアクターを生成できます。トップレベルのアクターはアクターシステムが提供しているガーディアンアクターによって監視されます。一方でコンテクストから生成したアクターはそのアクターの子アクターになります。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FirstActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;myChild&quot;</span><span class="o">)</span>
  <span class="c1">// plus some behavior ...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>子供から孫といった階層を作るようにしてください。そのようにすることでアプリケーションの論理的なエラー処理の構造を作ることができます。詳しくは:ref:<a href="#id1"><span class="problematic" id="id2">`</span></a>actor-systems`を参照してください。</p>
<p>:meth:<a href="#id1"><span class="problematic" id="id2">`</span></a>actorOf`を呼ぶことで:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>ActorRef`のインスタンスを得ることができます。:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>ActorRef`はアクターのインスタンスとつながっていて、アクターと対話するための唯一の手段となります。:class:<a href="#id7"><span class="problematic" id="id8">`</span></a>ActorRef`は不変でそれが表現しているアクターと一対一の関係を持っています。:class:<a href="#id9"><span class="problematic" id="id10">`</span></a>ActorRef`は永続化可能なのでネットワークを介することができます。つまり、シリアライズしたインスタンスをリモートのホストに送信した場合、元のノードのアクターをネットワークを超えて表現することができます。</p>
<p>nameパラメータはオプションですがアクターには名前を与えた方がよいでしょう。なぜなら、アクターの名前はログメッセージでアクターを識別するために用いるからです。アクターの名前は空文字や&quot;$&quot;から始まる文字列は許可されていませんが、そうした名前がURLにエンコードされた文字には含まれることがあります。(例えば、&quot;%20&quot;は空白文字です。)もじ与えられた名前が既に同じ親を持つ他の子アクターが利用していた場合、:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>InvalidActorNameException`がスローされます。</p>
<p>アクターは生成されたら非同期に自動的に開始されます。</p>
<div class="section" id="value-classes-as-constructor-arguments">
<h4>コンストラクタ引数の値クラス</h4>
<p>アクターのpropsのインスタンスを得るための推奨される方法ではアクターのどのコンストラクタを呼ぶのが正しいのかを調べるためにリフレクションを使っています。この技術的な制限のため、値クラスを引き数として受け取るコンストラクタの利用はサポートされていません。こういったケースでは値クラスの中の値をあらかじめ取り出しておくかコンストラクタを直接呼び出すようなpropsを作る必要があります。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Argument</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">ValueClassActor</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ValueClassActor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">props1</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ValueClassActor</span><span class="o">],</span> <span class="n">arg</span><span class="o">)</span> <span class="c1">// fails at runtime</span>
  <span class="k">def</span> <span class="n">props2</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ValueClassActor</span><span class="o">],</span> <span class="n">arg</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="c1">// ok</span>
  <span class="k">def</span> <span class="n">props3</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">ValueClassActor</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="c1">// ok</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dependency-injection">
<h3>依存性の注入</h3>
<p>アクターがコンストラクタで引数を受け取る場合、<a href="#id1"><span class="problematic" id="id2">`</span></a>すでに述べたように`__それは:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Props`の生成の中で利用する必要があります。しかし、ファクトリメソッドを用意していたとしても直接コンストラクタを使うケースがあります。例えば依存性の注入を行うフレームワークがコンストラクタの引数を調べる場合です。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.IndirectActorProducer</span>

<span class="k">class</span> <span class="nc">DependencyInjector</span><span class="o">(</span><span class="n">applicationContext</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">,</span> <span class="n">beanName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">IndirectActorProducer</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">actorClass</span> <span class="k">=</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">Actor</span><span class="o">]</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">produce</span> <span class="k">=</span>
    <span class="c1">// obtain fresh Actor instance from DI framework ...</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">actorRef</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span>
  <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">DependencyInjector</span><span class="o">],</span> <span class="n">applicationContext</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">),</span>
  <span class="s">&quot;helloBean&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>IndirectActorProducer`が必要な時に``lazy val``などを使って常に同じインスタンスを得たいと思うかもしれません。しかし、同じアクターのインスタンスを使いまわすということはは:ref:<a href="#id3"><span class="problematic" id="id4">`</span></a>supervision-restart`で述べてるようなアクターの再起動といった概念と衝突するためサポートされていません。</p>
<p class="last">依存性の注入を行うフレームワークを使う場合、アクターのbeanはシングルトンスコープであることは*許可されません*。</p>
</div>
<p>依存性の注入のためのテクニックや依存性注入を行うフレームワークとの統合については`Using Akka with Dependency Injection  &lt;<a class="reference external" href="http://letitcrash.com/post/55958814293/akka-dependency-injection">http://letitcrash.com/post/55958814293/akka-dependency-injection</a>&gt;`_ guidelineやLightbend Activatorの中の`Akka Java Spring &lt;<a class="reference external" href="http://www.lightbend.com/activator/template/akka-java-spring">http://www.lightbend.com/activator/template/akka-java-spring</a>&gt;`_ tutorialにより詳しい情報があります。</p>
</div>
<div class="section" id="the-inbox">
<h3>Inbox</h3>
<p>アクターの外側のコードからアクターと通信をする場合、<a href="#id1"><span class="problematic" id="id2">``</span></a>ask``パターン(後で出てきます)を使うのが一つの方法ですが、それを使えない場合が二つあります。一つは複数のメッセージを受け取るような場合(例えば通知サービスとして実装されている:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>ActorRef`を購読する場合)で、もう一つはActorのライフサイクルをwatchしている場合です。こういった場合のために:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>Inbox`というクラスが用意されています。</p>
<p>このコードでは:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Inbox`から:class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Inbox`への暗黙的な変換が行われています。つまりこの例ではsenderへの参照は暗黙的に:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>Inbox`に対するものになります。このようにすることで最後の行に書かれているようなやり方で応答を受け取ることができます。アクターをwatchする方法も簡単です。</p>
</div>
</div>
<div class="section" id="actor-api">
<h2>Actor API</h2>
<p><code class="xref py py-class docutils literal"><span class="pre">Actor</span></code> traitには、抽象メソッドが一つしか定義されていません。それはすでに述べた:meth:<a href="#id1"><span class="problematic" id="id2">`</span></a>receive`メソッドで、アクターの振る舞いを実装するメソッドです。</p>
<p>現在のアクターの振る舞いが受け取ったメッセージを処理できない場合、:meth:<a href="#id1"><span class="problematic" id="id2">`</span></a>unhandled`が呼ばれ、そのデフォルトの実装では``akka.actor.UnhandledMessage(message, sender, recipient)``をアクターシステムのイベントストリームに発行します(これは``akka.actor.debug.unhandled``という設定を``on``にすることで実際のデバッグのメッセージに変換されます)。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Actor</span></code> traitには他にも以下のようなメソッドがあります。</p>
<ul>
<li><p class="first"><code class="xref py py-obj docutils literal"><span class="pre">self</span></code> このアクター自身の:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>ActorRef`への参照</p>
</li>
<li><p class="first"><code class="xref py py-obj docutils literal"><span class="pre">sender</span></code> 最後に受け取ったメッセージの送信者となるActorへの参照。通常:ref:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor.Reply`で述べているような用途で使います。</p>
</li>
<li><p class="first"><code class="xref py py-obj docutils literal"><span class="pre">supervisorStrategy</span></code> ユーザがオーバーライド可能な子アクターをどう監視するかというストラテジーの定義</p>
<p>このストラテジーは戦略を決めるための関数の中でアクターの内部状態にアクセスするため、通常アクターの中で宣言します。障害は supervisor にメッセージとして通知され、他のメッセージと同じように処理されます。(通常の振る舞いの外側に置かれるものの)この関数の中ではアクター内部の全ての値や変数、&quot;sender&quot;への参照を利用することができます。(これは直接の子アクターが報告した障害の情報に含まれます。元となる障害が孫以上の子孫の場合でも障害が起きた階層の sender が報告されます。)</p>
</li>
<li><p class="first"><code class="xref py py-obj docutils literal"><span class="pre">context</span></code> アクターや現在のメッセージに関するコンテクスト情報を参照できます。これには以下のようなものがあります。</p>
<ul class="simple">
<li><p class="first">子アクターを作るためのファクトリメソッド(<code class="xref py py-meth docutils literal"><span class="pre">actorOf</span></code>)</p>
</li>
<li><p class="first">アクターが所属しているシステム</p>
</li>
<li><p class="first">supervisorである親アクター</p>
</li>
<li><p class="first">監視している子アクター</p>
</li>
<li><p class="first">ライフサイクルの監視</p>
</li>
<li><p class="first">:ref:<a href="#id1"><span class="problematic" id="id2">`</span></a>Actor.Hotswap`に書かれている動的に置き換え可能な振る舞いのスタック</p>
</li>
</ul>
</li>
</ul>
<p>:obj:<a href="#id1"><span class="problematic" id="id2">`</span></a>context`のメンバーをimportすることで&quot;context&quot;というプレフィックスなしにそのメンバにアクセスすることができます。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FirstActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">context._</span>
  <span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;myactor&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">myActor</span> <span class="o">!</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>ここまででまだ残っているアクセス可能なメソッドはユーザがオーバーライドすることで以下の述べるアクターのライフサイクルにフックすることができるメソッドです。</p>
<p>ここまでに紹介した実装は:class:<cite>Actor</cite> traitを使うことでデフォルトで利用できます。</p>
<div class="section" id="actor-lifecycle">
<span id="actor-lifecycle-scala"></span><h3>アクターのライフサクル</h3>
<a class="reference internal image-reference" href="../_images/actor_lifecycle1.png"><img alt="../_images/actor_lifecycle1.png" class="align-center" src="../_images/actor_lifecycle1.png" style="width: 680px;" /></a>
<p>アクターシステムにおけるパスは生存しているアクターによって占有されている&quot;場所&quot;を表現しています。始めは(システムによって初期化されたアクターを除き)パスは空になっています。 <code class="docutils literal"><span class="pre">actorOf()</span></code> を呼びだすと <code class="docutils literal"><span class="pre">Prop</span></code> で表現されたアクターの*インカーネーション*が与えられたパスに生成されます。アクターのインカーネーションはパスと <em>UID</em> によって識別されます。再起動が行われたときには <code class="docutils literal"><span class="pre">Actor</span></code> のインスタンスは置き換えられますが、インカーネーションの方は置き換えられないので UID は同じものになります。</p>
<p>アクターのインカーネーションのライフサイクルはアクターが停止した時に終わります。この時、これに対応したライフサイクルの終了イベントが呼ばれ、これを watch しているアクターに停止が通知されます。インカーネーションが停止したのち、インカーネーションのパスは再び <code class="docutils literal"><span class="pre">actorOf()</span></code> を使って再利用することができるようになります。この場合新しいインカーネーションの名前は前のものと同じですがUIDは別のものになります。アクターは自分自身や他のアクター、あるいは``ActorSystem``によって停止されることがあります。(:ref:<a href="#id1"><span class="problematic" id="id2">`</span></a>stopping-actors-scala`を参照)</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">アクターは参照されなくなったとしても自動的に停止することはないという点は重要です。生成された全てのアクターは明示的に破棄する必要があります。ただし親のアクターを停止する場合、そのアクターが生成した全ての子供のアクターも停止されるのでこの点は単純です。</p>
</div>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>ActorRef``はただ単に与えられたパスを表現しているのではなくいつでもインカーネーション(パスとUID)を表現しています。つまりアクターを停止して同じ名前のアクターを生成した場合、新しく生成した``ActorRef``は古いインカーネーションでなく新しいインカーネーションを指しています。</p>
<p>一方で <code class="docutils literal"><span class="pre">ActorSelection</span></code> はパスを示していて(ワイルドカードを使った場合は複数のパスを指します。)、現在そのパスを持っているのがどのインカーネーションなのかを完全に識別することができます。このため <code class="docutils literal"><span class="pre">ActorSelection</span></code> を watch することはできません。パスに存在するインカーネーションを watch するためには、<code class="docutils literal"><span class="pre">ActorSelection</span></code> に対して <code class="docutils literal"><span class="pre">Identity</span></code> メッセージを送信し <code class="docutils literal"><span class="pre">ActorSelection</span></code> から応答として <code class="docutils literal"><span class="pre">ActorIdentity</span></code> を受け取り、その中に含まれる正しい参照(<span class="xref std std-ref">actorSelection-scala`を参照)を使って現在のインカーネーションの ``ActorRef`</span> を解決します。 <code class="docutils literal"><span class="pre">ActorSelection</span></code> が持つ <code class="docutils literal"><span class="pre">resolveOne</span></code> を使うとパスにマッチした <code class="docutils literal"><span class="pre">ActorRef</span></code> の <code class="docutils literal"><span class="pre">Future</span></code> が戻されるので同じようなことができます。</p>
</div>
<div class="section" id="lifecycle-monitoring-aka-deathwatch">
<span id="deathwatch-scala"></span><h3>ライフサイクルの監視、DeathWatch</h3>
<p>他のアクターの停止を知るために(例えば、永久に停止された場合や一時的ではない障害によって再起動された場合など)、アクターは他のアクターが停止時に発する <code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code> メッセージを受け取るようにすることができます。(<cite>Stopping Actors`_も参照のこと)この機能はアクターシステムの :class:`DeathWatch</cite> というコンポーネントによって提供されています。</p>
<p>モニターを登録するのは簡単です。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">Terminated</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">WatchActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="s">&quot;child&quot;</span><span class="o">)</span>
  <span class="n">context</span><span class="o">.</span><span class="n">watch</span><span class="o">(</span><span class="n">child</span><span class="o">)</span> <span class="c1">// &lt;-- this is the only call needed for registration</span>
  <span class="k">var</span> <span class="n">lastSender</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">deadLetters</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;kill&quot;</span> <span class="k">=&gt;</span>
      <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">child</span><span class="o">);</span> <span class="n">lastSender</span> <span class="k">=</span> <span class="n">sender</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">`child`</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">lastSender</span> <span class="o">!</span> <span class="s">&quot;finished&quot;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code> メッセージは登録や停止がどのような順番で起きたかとは独立して生成されることに注意してください。典型的な例として、監視を行うアクターは例え監視の登録を行った時点ですでに監視対象のアクターが停止されていたとしても <code class="xref py py-class docutils literal"><span class="pre">Treminated</span></code> メッセージを受け取ることになります。</p>
<p>監視の登録を複数回行うことが必ずしも複数のメッセージを作ることになるわけではありませんが、こうしたメッセージを正確に一度受け取ることができる保障はありません。監視対象のアクターの停止メッセージが作られてキューに入ってから、このメッセージが処理される前に他のところで登録が行われたら、二つ目のメッセージがキューに入ります。何故なら既に停止したアクターの監視を登録すると、直ちに: class:<cite>Terminated</cite> が生成されるためです。</p>
<p>同じようなことが他のアクターの生存監視を <code class="docutils literal"><span class="pre">context.unwatch(target)</span></code> を使ってやめた場合にも起こりえます。これは例え <code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code> メッセージがメールボックスに入っていたとしても、<code class="xref py py-meth docutils literal"><span class="pre">unwatch`の呼び出しの後には監視を停止したアクターの</span> <span class="pre">:class:`Terminated</span></code> メッセージは処理されないためです。</p>
</div>
<div class="section" id="start-hook">
<span id="start-hook-scala"></span><h3>Start Hook</h3>
<p>Right after starting the actor, its <code class="xref py py-meth docutils literal"><span class="pre">preStart</span></code> method is invoked.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">child</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="s">&quot;child&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This method is called when the actor is first created. During restarts it is
called by the default implementation of <code class="xref py py-meth docutils literal"><span class="pre">postRestart</span></code>, which means that
by overriding that method you can choose whether the initialization code in
this method is called only exactly once for this actor or for every restart.
Initialization code which is part of the actor’s constructor will always be
called when an instance of the actor class is created, which happens at every
restart.</p>
</div>
<div class="section" id="restart-hooks">
<span id="restart-hook-scala"></span><h3>Restart Hooks</h3>
<p>All actors are supervised, i.e. linked to another actor with a fault
handling strategy. Actors may be restarted in case an exception is thrown while
processing a message (see <a class="reference internal" href="../general/supervision.html#supervision"><span class="std std-ref">Supervision and Monitoring</span></a>). This restart involves the hooks
mentioned above:</p>
<ol class="arabic">
<li><p class="first">The old actor is informed by calling <code class="xref py py-meth docutils literal"><span class="pre">preRestart</span></code> with the exception
which caused the restart and the message which triggered that exception; the
latter may be <code class="docutils literal"><span class="pre">None</span></code> if the restart was not caused by processing a
message, e.g. when a supervisor does not trap the exception and is restarted
in turn by its supervisor, or if an actor is restarted due to a sibling’s
failure. If the message is available, then that message’s sender is also
accessible in the usual way (i.e. by calling <code class="docutils literal"><span class="pre">sender</span></code>).</p>
<p>This method is the best place for cleaning up, preparing hand-over to the
fresh actor instance, etc.  By default it stops all children and calls
<code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code>.</p>
</li>
<li><p class="first">The initial factory from the <code class="docutils literal"><span class="pre">actorOf</span></code> call is used
to produce the fresh instance.</p>
</li>
<li><p class="first">The new actor’s <code class="xref py py-meth docutils literal"><span class="pre">postRestart</span></code> method is invoked with the exception
which caused the restart. By default the <code class="xref py py-meth docutils literal"><span class="pre">preStart</span></code>
is called, just as in the normal start-up case.</p>
</li>
</ol>
<p>An actor restart replaces only the actual actor object; the contents of the
mailbox is unaffected by the restart, so processing of messages will resume
after the <code class="xref py py-meth docutils literal"><span class="pre">postRestart</span></code> hook returns. The message
that triggered the exception will not be received again. Any message
sent to an actor while it is being restarted will be queued to its mailbox as
usual.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Be aware that the ordering of failure notifications relative to user messages
is not deterministic. In particular, a parent might restart its child before
it has processed the last messages sent by the child before the failure.
See <a class="reference internal" href="../general/message-delivery-reliability.html#message-ordering"><span class="std std-ref">Discussion: Message Ordering</span></a> for details.</p>
</div>
</div>
<div class="section" id="stop-hook">
<span id="stop-hook-scala"></span><h3>Stop Hook</h3>
<p>After stopping an actor, its <code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code> hook is called, which may be used
e.g. for deregistering this actor from other services. This hook is guaranteed
to run after message queuing has been disabled for this actor, i.e. messages
sent to a stopped actor will be redirected to the <code class="xref py py-obj docutils literal"><span class="pre">deadLetters</span></code> of the
<code class="xref py py-obj docutils literal"><span class="pre">ActorSystem</span></code>.</p>
</div>
</div>
<div class="section" id="actorselection-scala">
<span id="identifying-actors-via-actor-selection"></span><h2>Identifying Actors via Actor Selection</h2>
<p>As described in <a class="reference internal" href="../general/addressing.html#addressing"><span class="std std-ref">Actor References, Paths and Addresses</span></a>, each actor has a unique logical path, which
is obtained by following the chain of actors from child to parent until
reaching the root of the actor system, and it has a physical path, which may
differ if the supervision chain includes any remote supervisors. These paths
are used by the system to look up actors, e.g. when a remote message is
received and the recipient is searched, but they are also useful more directly:
actors may look up other actors by specifying absolute or relative
paths—logical or physical—and receive back an <code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code> with the
result:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// will look up this absolute path</span>
<span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/serviceA/aggregator&quot;</span><span class="o">)</span>
<span class="c1">// will look up sibling beneath same supervisor</span>
<span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;../joe&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>It is always preferable to communicate with other Actors using their ActorRef
instead of relying upon ActorSelection. Exceptions are</p>
<blockquote>
<div><ul class="simple">
<li>sending messages using the <a class="reference internal" href="persistence.html#at-least-once-delivery-scala"><span class="std std-ref">At-Least-Once Delivery</span></a> facility</li>
<li>initiating first contact with a remote system</li>
</ul>
</div></blockquote>
<p class="last">In all other cases ActorRefs can be provided during Actor creation or
initialization, passing them from parent to child or introducing Actors by
sending their ActorRefs to other Actors within messages.</p>
</div>
<p>The supplied path is parsed as a <code class="xref py py-class docutils literal"><span class="pre">java.net.URI</span></code>, which basically means
that it is split on <code class="docutils literal"><span class="pre">/</span></code> into path elements. If the path starts with <code class="docutils literal"><span class="pre">/</span></code>, it
is absolute and the look-up starts at the root guardian (which is the parent of
<code class="docutils literal"><span class="pre">&quot;/user&quot;</span></code>); otherwise it starts at the current actor. If a path element equals
<code class="docutils literal"><span class="pre">..</span></code>, the look-up will take a step “up” towards the supervisor of the
currently traversed actor, otherwise it will step “down” to the named child.
It should be noted that the <code class="docutils literal"><span class="pre">..</span></code> in actor paths here always means the logical
structure, i.e. the supervisor.</p>
<p>The path elements of an actor selection may contain wildcard patterns allowing for
broadcasting of messages to that section:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// will look all children to serviceB with names starting with worker</span>
<span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/serviceB/worker*&quot;</span><span class="o">)</span>
<span class="c1">// will look up all siblings beneath same supervisor</span>
<span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;../*&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Messages can be sent via the <code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code> and the path of the
<code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code> is looked up when delivering each message. If the selection
does not match any actors the message will be dropped.</p>
<p>To acquire an <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> for an <code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code> you need to send
a message to the selection and use the <code class="docutils literal"><span class="pre">sender()</span></code> reference of the reply from
the actor. There is a built-in <code class="docutils literal"><span class="pre">Identify</span></code> message that all Actors will
understand and automatically reply to with a <code class="docutils literal"><span class="pre">ActorIdentity</span></code> message
containing the <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code>. This message is handled specially by the
actors which are traversed in the sense that if a concrete name lookup fails
(i.e. a non-wildcard path element does not correspond to a live actor) then a
negative result is generated. Please note that this does not mean that delivery
of that reply is guaranteed, it still is a normal message.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">Props</span><span class="o">,</span> <span class="nc">Identify</span><span class="o">,</span> <span class="nc">ActorIdentity</span><span class="o">,</span> <span class="nc">Terminated</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">Follower</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">identifyId</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;/user/another&quot;</span><span class="o">)</span> <span class="o">!</span> <span class="nc">Identify</span><span class="o">(</span><span class="n">identifyId</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ActorIdentity</span><span class="o">(</span><span class="n">`identifyId`</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ref</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="n">context</span><span class="o">.</span><span class="n">watch</span><span class="o">(</span><span class="n">ref</span><span class="o">)</span>
      <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">active</span><span class="o">(</span><span class="n">ref</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">ActorIdentity</span><span class="o">(</span><span class="n">`identifyId`</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>

  <span class="o">}</span>

  <span class="k">def</span> <span class="n">active</span><span class="o">(</span><span class="n">another</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Actor.Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">`another`</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>You can also acquire an <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> for an <code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code> with
the <code class="docutils literal"><span class="pre">resolveOne</span></code> method of the <code class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></code>. It returns a <code class="docutils literal"><span class="pre">Future</span></code>
of the matching <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code> if such an actor exists. It is completed with
failure [[akka.actor.ActorNotFound]] if no such actor exists or the identification
didn't complete within the supplied <cite>timeout</cite>.</p>
<p>Remote actor addresses may also be looked up, if <a class="reference internal" href="remoting.html#remoting-scala"><span class="std std-ref">remoting</span></a> is enabled:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;akka.tcp://app@otherhost:1234/user/serviceB&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>An example demonstrating actor look-up is given in <a class="reference internal" href="remoting.html#remote-sample-scala"><span class="std std-ref">Remoting Sample</span></a>.</p>
</div>
<div class="section" id="messages-and-immutability">
<h2>Messages and immutability</h2>
<p><strong>IMPORTANT</strong>: Messages can be any kind of object but have to be
immutable. Scala can’t enforce immutability (yet) so this has to be by
convention. Primitives like String, Int, Boolean are always immutable. Apart
from these the recommended approach is to use Scala case classes which are
immutable (if you don’t explicitly expose the state) and works great with
pattern matching at the receiver side.</p>
<p>以下はこのサンプルコードです。</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// define the case class</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Register</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span>

<span class="c1">// create a new case class message</span>
<span class="k">val</span> <span class="n">message</span> <span class="k">=</span> <span class="nc">Register</span><span class="o">(</span><span class="n">user</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="send-messages">
<h2>Send messages</h2>
<p>Messages are sent to an Actor through one of the following methods.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">!</span></code> means “fire-and-forget”, e.g. send a message asynchronously and return
immediately. Also known as <code class="docutils literal"><span class="pre">tell</span></code>.</li>
<li><code class="docutils literal"><span class="pre">?</span></code> sends a message asynchronously and returns a <code class="xref py py-class docutils literal"><span class="pre">Future</span></code>
representing a possible reply. Also known as <code class="docutils literal"><span class="pre">ask</span></code>.</li>
</ul>
<p>Message ordering is guaranteed on a per-sender basis.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">There are performance implications of using <code class="docutils literal"><span class="pre">ask</span></code> since something needs to
keep track of when it times out, there needs to be something that bridges
a <code class="docutils literal"><span class="pre">Promise</span></code> into an <code class="docutils literal"><span class="pre">ActorRef</span></code> and it also needs to be reachable through
remoting. So always prefer <code class="docutils literal"><span class="pre">tell</span></code> for performance, and only <code class="docutils literal"><span class="pre">ask</span></code> if you must.</p>
</div>
<div class="section" id="tell-fire-forget">
<span id="actors-tell-sender-scala"></span><h3>Tell: Fire-forget</h3>
<p>This is the preferred way of sending messages. No blocking waiting for a
message. This gives the best concurrency and scalability characteristics.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">actorRef</span> <span class="o">!</span> <span class="n">message</span>
</pre></div>
</div>
<p>If invoked from within an Actor, then the sending actor reference will be
implicitly passed along with the message and available to the receiving Actor
in its <code class="docutils literal"><span class="pre">sender():</span> <span class="pre">ActorRef</span></code> member method. The target actor can use this
to reply to the original sender, by using <code class="docutils literal"><span class="pre">sender()</span> <span class="pre">!</span> <span class="pre">replyMsg</span></code>.</p>
<p>If invoked from an instance that is <strong>not</strong> an Actor the sender will be
<code class="xref py py-obj docutils literal"><span class="pre">deadLetters</span></code> actor reference by default.</p>
</div>
<div class="section" id="ask-send-and-receive-future">
<span id="actors-ask-scala"></span><h3>Ask: Send-And-Receive-Future</h3>
<p>The <code class="docutils literal"><span class="pre">ask</span></code> pattern involves actors as well as futures, hence it is offered as
a use pattern rather than a method on <code class="xref py py-class docutils literal"><span class="pre">ActorRef</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.pattern.</span><span class="o">{</span> <span class="n">ask</span><span class="o">,</span> <span class="n">pipe</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">system.dispatcher</span> <span class="c1">// The ExecutionContext that will be used</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Result</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Request</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span> <span class="c1">// needed for `?` below</span>

<span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">ask</span><span class="o">(</span><span class="n">actorA</span><span class="o">,</span> <span class="nc">Request</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="c1">// call pattern directly</span>
    <span class="n">s</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">actorB</span> <span class="n">ask</span> <span class="nc">Request</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="c1">// call by implicit conversion</span>
    <span class="n">d</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">actorC</span> <span class="o">?</span> <span class="nc">Request</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="c1">// call by symbolic name</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="nc">Result</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>

<span class="n">f</span> <span class="n">pipeTo</span> <span class="n">actorD</span> <span class="c1">// .. or ..</span>
<span class="n">pipe</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="n">to</span> <span class="n">actorD</span>
</pre></div>
</div>
<p>This example demonstrates <code class="docutils literal"><span class="pre">ask</span></code> together with the <code class="docutils literal"><span class="pre">pipeTo</span></code> pattern on
futures, because this is likely to be a common combination. Please note that
all of the above is completely non-blocking and asynchronous: <code class="docutils literal"><span class="pre">ask</span></code> produces
a <code class="xref py py-class docutils literal"><span class="pre">Future</span></code>, three of which are composed into a new future using the
for-comprehension and then <code class="docutils literal"><span class="pre">pipeTo</span></code> installs an <code class="docutils literal"><span class="pre">onComplete</span></code>-handler on the
future to affect the submission of the aggregated <code class="xref py py-class docutils literal"><span class="pre">Result</span></code> to another
actor.</p>
<p>Using <code class="docutils literal"><span class="pre">ask</span></code> will send a message to the receiving Actor as with <code class="docutils literal"><span class="pre">tell</span></code>, and
the receiving actor must reply with <code class="docutils literal"><span class="pre">sender()</span> <span class="pre">!</span> <span class="pre">reply</span></code> in order to complete the
returned <code class="xref py py-class docutils literal"><span class="pre">Future</span></code> with a value. The <code class="docutils literal"><span class="pre">ask</span></code> operation involves creating
an internal actor for handling this reply, which needs to have a timeout after
which it is destroyed in order not to leak resources; see more below.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">To complete the future with an exception you need send a Failure message to the sender.
This is <em>not done automatically</em> when an actor throws an exception while processing a message.</p>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">()</span>
  <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">result</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
    <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">akka</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="nc">Status</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
    <span class="k">throw</span> <span class="n">e</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If the actor does not complete the future, it will expire after the timeout
period, completing it with an <code class="xref py py-class docutils literal"><span class="pre">AskTimeoutException</span></code>.  The timeout is
taken from one of the following locations in order of precedence:</p>
<ol class="arabic simple">
<li>explicitly given timeout as in:</li>
</ol>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">myActor</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>implicit argument of type <code class="xref py py-class docutils literal"><span class="pre">akka.util.Timeout</span></code>, e.g.</li>
</ol>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">myActor</span> <span class="o">?</span> <span class="s">&quot;hello&quot;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="futures.html#futures-scala"><span class="std std-ref">Futures</span></a> for more information on how to await or query a
future.</p>
<p>The <code class="docutils literal"><span class="pre">onComplete</span></code>, <code class="docutils literal"><span class="pre">onSuccess</span></code>, or <code class="docutils literal"><span class="pre">onFailure</span></code> methods of the <code class="docutils literal"><span class="pre">Future</span></code> can be
used to register a callback to get a notification when the Future completes, giving
you a way to avoid blocking.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">When using future callbacks, such as <code class="docutils literal"><span class="pre">onComplete</span></code>, <code class="docutils literal"><span class="pre">onSuccess</span></code>, and <code class="docutils literal"><span class="pre">onFailure</span></code>,
inside actors you need to carefully avoid closing over
the containing actor’s reference, i.e. do not call methods or access mutable state
on the enclosing actor from within the callback. This would break the actor
encapsulation and may introduce synchronization bugs and race conditions because
the callback will be scheduled concurrently to the enclosing actor. Unfortunately
there is not yet a way to detect these illegal accesses at compile time.
See also: <a class="reference internal" href="../general/jmm.html#jmm-shared-state"><span class="std std-ref">アクターと共有可変状態</span></a></p>
</div>
</div>
<div class="section" id="forward-message">
<h3>Forward message</h3>
<p>You can forward a message from one actor to another. This means that the
original sender address/reference is maintained even though the message is going
through a 'mediator'. This can be useful when writing actors that work as
routers, load-balancers, replicators etc.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">target</span> <span class="n">forward</span> <span class="n">message</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receive-messages">
<h2>Receive messages</h2>
<p>An Actor has to implement the <code class="docutils literal"><span class="pre">receive</span></code> method to receive messages:</p>
<p>This method returns a <code class="docutils literal"><span class="pre">PartialFunction</span></code>, e.g. a ‘match/case’ clause in
which the message can be matched against the different case clauses using Scala
pattern matching. Here is an example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;test&quot;</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received test&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span>      <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;received unknown message&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reply-to-messages">
<span id="actor-reply"></span><h2>Reply to messages</h2>
<p>If you want to have a handle for replying to a message, you can use
<code class="docutils literal"><span class="pre">sender()</span></code>, which gives you an ActorRef. You can reply by sending to
that ActorRef with <code class="docutils literal"><span class="pre">sender()</span> <span class="pre">!</span> <span class="pre">replyMsg</span></code>. You can also store the ActorRef
for replying later, or passing on to other actors. If there is no sender (a
message was sent without an actor or future context) then the sender
defaults to a 'dead-letter' actor ref.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">result</span>       <span class="c1">// will have dead-letter actor as default</span>
</pre></div>
</div>
</div>
<div class="section" id="receive-timeout">
<h2>Receive timeout</h2>
<p>The <cite>ActorContext</cite> <code class="xref py py-meth docutils literal"><span class="pre">setReceiveTimeout</span></code> defines the inactivity timeout after which
the sending of a <cite>ReceiveTimeout</cite> message is triggered.
When specified, the receive function should be able to handle an <cite>akka.actor.ReceiveTimeout</cite> message.
1 millisecond is the minimum supported timeout.</p>
<p>Please note that the receive timeout might fire and enqueue the <cite>ReceiveTimeout</cite> message right after
another message was enqueued; hence it is <strong>not guaranteed</strong> that upon reception of the receive
timeout there must have been an idle period beforehand as configured via this method.</p>
<p>Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
periods). Pass in <cite>Duration.Undefined</cite> to switch off this feature.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.ReceiveTimeout</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// To set an initial delay</span>
  <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="mi">30</span> <span class="n">milliseconds</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;Hello&quot;</span> <span class="k">=&gt;</span>
      <span class="c1">// To set in a response to a message</span>
      <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="mi">100</span> <span class="n">milliseconds</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span>
      <span class="c1">// To turn it off</span>
      <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="nc">Undefined</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;Receive timed out&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Messages marked with <code class="docutils literal"><span class="pre">NotInfluenceReceiveTimeout</span></code> will not reset the timer. This can be useful when
<code class="docutils literal"><span class="pre">ReceiveTimeout</span></code> should be fired by external inactivity but not influenced by internal activity,
e.g. scheduled tick messages.</p>
</div>
<div class="section" id="stopping-actors">
<span id="stopping-actors-scala"></span><h2>Stopping actors</h2>
<p>Actors are stopped by invoking the <code class="xref py py-meth docutils literal"><span class="pre">stop</span></code> method of a <code class="docutils literal"><span class="pre">ActorRefFactory</span></code>,
i.e. <code class="docutils literal"><span class="pre">ActorContext</span></code> or <code class="docutils literal"><span class="pre">ActorSystem</span></code>. Typically the context is used for stopping
the actor itself or child actors and the system for stopping top level actors. The actual
termination of the actor is performed asynchronously, i.e. <code class="xref py py-meth docutils literal"><span class="pre">stop</span></code> may return before
the actor is stopped.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">child</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;interrupt-child&quot;</span> <span class="k">=&gt;</span>
      <span class="n">context</span> <span class="n">stop</span> <span class="n">child</span>

    <span class="k">case</span> <span class="s">&quot;done&quot;</span> <span class="k">=&gt;</span>
      <span class="n">context</span> <span class="n">stop</span> <span class="n">self</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>
</div>
<p>Processing of the current message, if any, will continue before the actor is stopped,
but additional messages in the mailbox will not be processed. By default these
messages are sent to the <code class="xref py py-obj docutils literal"><span class="pre">deadLetters</span></code> of the <code class="xref py py-obj docutils literal"><span class="pre">ActorSystem</span></code>, but that
depends on the mailbox implementation.</p>
<p>Termination of an actor proceeds in two steps: first the actor suspends its
mailbox processing and sends a stop command to all its children, then it keeps
processing the internal termination notifications from its children until the last one is
gone, finally terminating itself (invoking <code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code>, dumping mailbox,
publishing <code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code> on the <a class="reference internal" href="#deathwatch-scala"><span class="std std-ref">DeathWatch</span></a>, telling
its supervisor). This procedure ensures that actor system sub-trees terminate
in an orderly fashion, propagating the stop command to the leaves and
collecting their confirmation back to the stopped supervisor. If one of the
actors does not respond (i.e. processing a message for extended periods of time
and therefore not receiving the stop command), this whole process will be
stuck.</p>
<p>Upon <code class="xref py py-meth docutils literal"><span class="pre">ActorSystem.terminate</span></code>, the system guardian actors will be
stopped, and the aforementioned process will ensure proper termination of the
whole system.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">postStop</span></code> hook is invoked after an actor is fully stopped. This
enables cleaning up of resources:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// clean up some resources ...</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Since stopping an actor is asynchronous, you cannot immediately reuse the
name of the child you just stopped; this will result in an
<code class="xref py py-class docutils literal"><span class="pre">InvalidActorNameException</span></code>. Instead, <code class="xref py py-meth docutils literal"><span class="pre">watch</span></code> the terminating
actor and create its replacement in response to the <code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code>
message which will eventually arrive.</p>
</div>
<div class="section" id="poisonpill">
<span id="poison-pill-scala"></span><h3>PoisonPill</h3>
<p>You can also send an actor the <code class="docutils literal"><span class="pre">akka.actor.PoisonPill</span></code> message, which will
stop the actor when the message is processed. <code class="docutils literal"><span class="pre">PoisonPill</span></code> is enqueued as
ordinary messages and will be handled after messages that were already queued
in the mailbox.</p>
</div>
<div class="section" id="graceful-stop">
<h3>Graceful Stop</h3>
<p><code class="xref py py-meth docutils literal"><span class="pre">gracefulStop</span></code> is useful if you need to wait for termination or compose ordered
termination of several actors:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.pattern.gracefulStop</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>

<span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">stopped</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="n">gracefulStop</span><span class="o">(</span><span class="n">actorRef</span><span class="o">,</span> <span class="mi">5</span> <span class="n">seconds</span><span class="o">,</span> <span class="nc">Manager</span><span class="o">.</span><span class="nc">Shutdown</span><span class="o">)</span>
  <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">stopped</span><span class="o">,</span> <span class="mi">6</span> <span class="n">seconds</span><span class="o">)</span>
  <span class="c1">// the actor has been stopped</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="c1">// the actor wasn&#39;t stopped within 5 seconds</span>
  <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">akka.pattern.AskTimeoutException</span> <span class="o">=&gt;</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Manager</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Shutdown</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Manager</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Manager._</span>
  <span class="k">val</span> <span class="n">worker</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">watch</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Cruncher</span><span class="o">],</span> <span class="s">&quot;worker&quot;</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;job&quot;</span> <span class="k">=&gt;</span> <span class="n">worker</span> <span class="o">!</span> <span class="s">&quot;crunch&quot;</span>
    <span class="k">case</span> <span class="nc">Shutdown</span> <span class="k">=&gt;</span>
      <span class="n">worker</span> <span class="o">!</span> <span class="nc">PoisonPill</span>
      <span class="n">context</span> <span class="n">become</span> <span class="n">shuttingDown</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">shuttingDown</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;job&quot;</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="s">&quot;service unavailable, shutting down&quot;</span>
    <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">`worker`</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">context</span> <span class="n">stop</span> <span class="n">self</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">gracefulStop()</span></code> returns successfully, the actor’s <code class="docutils literal"><span class="pre">postStop()</span></code> hook
will have been executed: there exists a happens-before edge between the end of
<code class="docutils literal"><span class="pre">postStop()</span></code> and the return of <code class="docutils literal"><span class="pre">gracefulStop()</span></code>.</p>
<p>In the above example a custom <code class="docutils literal"><span class="pre">Manager.Shutdown</span></code> message is sent to the target
actor to initiate the process of stopping the actor. You can use <code class="docutils literal"><span class="pre">PoisonPill</span></code> for
this, but then you have limited possibilities to perform interactions with other actors
before stopping the target actor. Simple cleanup tasks can be handled in <code class="docutils literal"><span class="pre">postStop</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Keep in mind that an actor stopping and its name being deregistered are
separate events which happen asynchronously from each other. Therefore it may
be that you will find the name still in use after <code class="docutils literal"><span class="pre">gracefulStop()</span></code>
returned. In order to guarantee proper deregistration, only reuse names from
within a supervisor you control and only in response to a <code class="xref py py-class docutils literal"><span class="pre">Terminated</span></code>
message, i.e. not for top-level actors.</p>
</div>
</div>
</div>
<div class="section" id="become-unbecome">
<span id="actor-hotswap"></span><h2>Become/Unbecome</h2>
<div class="section" id="upgrade">
<h3>Upgrade</h3>
<p>Akka supports hotswapping the Actor’s message loop (e.g. its implementation) at
runtime: invoke the <code class="docutils literal"><span class="pre">context.become</span></code> method from within the Actor.
<code class="xref py py-meth docutils literal"><span class="pre">become</span></code> takes a <code class="docutils literal"><span class="pre">PartialFunction[Any,</span> <span class="pre">Unit]</span></code> that implements the new
message handler. The hotswapped code is kept in a Stack which can be pushed and
popped.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Please note that the actor will revert to its original behavior when restarted by its Supervisor.</p>
</div>
<p>To hotswap the Actor behavior using <code class="docutils literal"><span class="pre">become</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HotSwapActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">context._</span>
  <span class="k">def</span> <span class="n">angry</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="s">&quot;I am already angry?&quot;</span>
    <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">happy</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="s">&quot;I am already happy :-)&quot;</span>
    <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;foo&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">angry</span><span class="o">)</span>
    <span class="k">case</span> <span class="s">&quot;bar&quot;</span> <span class="k">=&gt;</span> <span class="n">become</span><span class="o">(</span><span class="n">happy</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This variant of the <code class="xref py py-meth docutils literal"><span class="pre">become</span></code> method is useful for many different things,
such as to implement a Finite State Machine (FSM, for an example see <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-fsm-scala">Dining
Hakkers</a>). It will replace the current behavior (i.e. the top of the behavior
stack), which means that you do not use <code class="xref py py-meth docutils literal"><span class="pre">unbecome</span></code>, instead always the
next behavior is explicitly installed.</p>
<p>The other way of using <code class="xref py py-meth docutils literal"><span class="pre">become</span></code> does not replace but add to the top of
the behavior stack. In this case care must be taken to ensure that the number
of “pop” operations (i.e. <code class="xref py py-meth docutils literal"><span class="pre">unbecome</span></code>) matches the number of “push” ones
in the long run, otherwise this amounts to a memory leak (which is why this
behavior is not the default).</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">object</span> <span class="nc">Swap</span>
<span class="k">class</span> <span class="nc">Swapper</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">context._</span>
  <span class="k">val</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="n">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Swap</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">)</span>
      <span class="n">become</span><span class="o">({</span>
        <span class="k">case</span> <span class="nc">Swap</span> <span class="k">=&gt;</span>
          <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Ho&quot;</span><span class="o">)</span>
          <span class="n">unbecome</span><span class="o">()</span> <span class="c1">// resets the latest &#39;become&#39; (just for fun)</span>
      <span class="o">},</span> <span class="n">discardOld</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// push on top instead of replace</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">SwapperApp</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;SwapperSystem&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">swap</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Swapper</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;swapper&quot;</span><span class="o">)</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Hi</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Ho</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Hi</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Ho</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Hi</span>
  <span class="n">swap</span> <span class="o">!</span> <span class="nc">Swap</span> <span class="c1">// logs Ho</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="encoding-scala-actors-nested-receives-without-accidentally-leaking-memory">
<h3>Encoding Scala Actors nested receives without accidentally leaking memory</h3>
<p>See this <a class="reference external" href="&#64;github&#64;/akka-docs/rst/scala/code/docs/actor/UnnestedReceives.scala">Unnested receive example</a>.</p>
</div>
</div>
<div class="section" id="stash">
<span id="stash-scala"></span><h2>Stash</h2>
<p>The <cite>Stash</cite> trait enables an actor to temporarily stash away messages
that can not or should not be handled using the actor's current
behavior. Upon changing the actor's message handler, i.e., right
before invoking <code class="docutils literal"><span class="pre">context.become</span></code> or <code class="docutils literal"><span class="pre">context.unbecome</span></code>, all
stashed messages can be &quot;unstashed&quot;, thereby prepending them to the actor's
mailbox. This way, the stashed messages can be processed in the same
order as they have been received originally.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The trait <code class="docutils literal"><span class="pre">Stash</span></code> extends the marker trait
<code class="docutils literal"><span class="pre">RequiresMessageQueue[DequeBasedMessageQueueSemantics]</span></code> which
requests the system to automatically choose a deque based
mailbox implementation for the actor. If you want more control over the
mailbox, see the documentation on mailboxes: <a class="reference internal" href="mailboxes.html#mailboxes-scala"><span class="std std-ref">Mailboxes</span></a>.</p>
</div>
<p>Here is an example of the <code class="docutils literal"><span class="pre">Stash</span></code> in action:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.Stash</span>
<span class="k">class</span> <span class="nc">ActorWithProtocol</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Stash</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;open&quot;</span> <span class="k">=&gt;</span>
      <span class="n">unstashAll</span><span class="o">()</span>
      <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">({</span>
        <span class="k">case</span> <span class="s">&quot;write&quot;</span> <span class="k">=&gt;</span> <span class="c1">// do writing...</span>
        <span class="k">case</span> <span class="s">&quot;close&quot;</span> <span class="k">=&gt;</span>
          <span class="n">unstashAll</span><span class="o">()</span>
          <span class="n">context</span><span class="o">.</span><span class="n">unbecome</span><span class="o">()</span>
        <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">stash</span><span class="o">()</span>
      <span class="o">},</span> <span class="n">discardOld</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// stack on top instead of replacing</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">stash</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Invoking <code class="docutils literal"><span class="pre">stash()</span></code> adds the current message (the message that the
actor received last) to the actor's stash. It is typically invoked
when handling the default case in the actor's message handler to stash
messages that aren't handled by the other cases. It is illegal to
stash the same message twice; to do so results in an
<code class="docutils literal"><span class="pre">IllegalStateException</span></code> being thrown. The stash may also be bounded
in which case invoking <code class="docutils literal"><span class="pre">stash()</span></code> may lead to a capacity violation,
which results in a <code class="docutils literal"><span class="pre">StashOverflowException</span></code>. The capacity of the
stash can be configured using the <code class="docutils literal"><span class="pre">stash-capacity</span></code> setting (an <code class="docutils literal"><span class="pre">Int</span></code>) of the
mailbox's configuration.</p>
<p>Invoking <code class="docutils literal"><span class="pre">unstashAll()</span></code> enqueues messages from the stash to the
actor's mailbox until the capacity of the mailbox (if any) has been
reached (note that messages from the stash are prepended to the
mailbox). In case a bounded mailbox overflows, a
<code class="docutils literal"><span class="pre">MessageQueueAppendFailedException</span></code> is thrown.
The stash is guaranteed to be empty after calling <code class="docutils literal"><span class="pre">unstashAll()</span></code>.</p>
<p>The stash is backed by a <code class="docutils literal"><span class="pre">scala.collection.immutable.Vector</span></code>. As a
result, even a very large number of messages may be stashed without a
major impact on performance.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Note that the <code class="docutils literal"><span class="pre">Stash</span></code> trait must be mixed into (a subclass of) the
<code class="docutils literal"><span class="pre">Actor</span></code> trait before any trait/class that overrides the <code class="docutils literal"><span class="pre">preRestart</span></code>
callback. This means it's not possible to write
<code class="docutils literal"><span class="pre">Actor</span> <span class="pre">with</span> <span class="pre">MyActor</span> <span class="pre">with</span> <span class="pre">Stash</span></code> if <code class="docutils literal"><span class="pre">MyActor</span></code> overrides <code class="docutils literal"><span class="pre">preRestart</span></code>.</p>
</div>
<p>Note that the stash is part of the ephemeral actor state, unlike the
mailbox. Therefore, it should be managed like other parts of the
actor's state which have the same property. The <code class="xref py py-class docutils literal"><span class="pre">Stash</span></code> trait’s
implementation of <code class="xref py py-meth docutils literal"><span class="pre">preRestart</span></code> will call <code class="docutils literal"><span class="pre">unstashAll()</span></code>, which is
usually the desired behavior.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you want to enforce that your actor can only work with an unbounded stash,
then you should use the <code class="docutils literal"><span class="pre">UnboundedStash</span></code> trait instead.</p>
</div>
</div>
<div class="section" id="killing-an-actor">
<span id="killing-actors-scala"></span><h2>Killing an Actor</h2>
<p>You can kill an actor by sending a <code class="docutils literal"><span class="pre">Kill</span></code> message. This will cause the actor
to throw a <code class="xref py py-class docutils literal"><span class="pre">ActorKilledException</span></code>, triggering a failure. The actor will
suspend operation and its supervisor will be asked how to handle the failure,
which may mean resuming the actor, restarting it or terminating it completely.
See <a class="reference internal" href="../general/supervision.html#supervision-directives"><span class="std std-ref">What Supervision Means</span></a> for more information.</p>
<p>Use <code class="docutils literal"><span class="pre">Kill</span></code> like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// kill the &#39;victim&#39; actor</span>
<span class="n">victim</span> <span class="o">!</span> <span class="nc">Kill</span>
</pre></div>
</div>
</div>
<div class="section" id="actors-and-exceptions">
<h2>Actors and exceptions</h2>
<p>It can happen that while a message is being processed by an actor, that some
kind of exception is thrown, e.g. a database exception.</p>
<div class="section" id="what-happens-to-the-message">
<h3>What happens to the Message</h3>
<p>If an exception is thrown while a message is being processed (i.e. taken out of
its mailbox and handed over to the current behavior), then this message will be
lost. It is important to understand that it is not put back on the mailbox. So
if you want to retry processing of a message, you need to deal with it yourself
by catching the exception and retry your flow. Make sure that you put a bound
on the number of retries since you don't want a system to livelock (so
consuming a lot of cpu cycles without making progress). Another possibility
would be to have a look at the <span class="xref std std-ref">PeekMailbox pattern</span>.</p>
</div>
<div class="section" id="what-happens-to-the-mailbox">
<h3>What happens to the mailbox</h3>
<p>If an exception is thrown while a message is being processed, nothing happens to
the mailbox. If the actor is restarted, the same mailbox will be there. So all
messages on that mailbox will be there as well.</p>
</div>
<div class="section" id="what-happens-to-the-actor">
<h3>What happens to the actor</h3>
<p>If code within an actor throws an exception, that actor is suspended and the
supervision process is started (see <a class="reference internal" href="../general/supervision.html#supervision"><span class="std std-ref">Supervision and Monitoring</span></a>). Depending on the
supervisor’s decision the actor is resumed (as if nothing happened), restarted
(wiping out its internal state and starting from scratch) or terminated.</p>
</div>
</div>
<div class="section" id="extending-actors-using-partialfunction-chaining">
<h2>Extending Actors using PartialFunction chaining</h2>
<p>Sometimes it can be useful to share common behavior among a few actors, or compose one actor's behavior from multiple smaller functions.
This is possible because an actor's <code class="xref py py-meth docutils literal"><span class="pre">receive</span></code> method returns an <code class="docutils literal"><span class="pre">Actor.Receive</span></code>, which is a type alias for <code class="docutils literal"><span class="pre">PartialFunction[Any,Unit]</span></code>,
and partial functions can be chained together using the <code class="docutils literal"><span class="pre">PartialFunction#orElse</span></code> method. You can chain as many functions as you need,
however you should keep in mind that &quot;first match&quot; wins - which may be important when combining functions that both can handle the same type of message.</p>
<p>For example, imagine you have a set of actors which are either <code class="docutils literal"><span class="pre">Producers</span></code> or <code class="docutils literal"><span class="pre">Consumers</span></code>, yet sometimes it makes sense to
have an actor share both behaviors. This can be easily achieved without having to duplicate code by extracting the behaviors to
traits and implementing the actor's <code class="xref py py-meth docutils literal"><span class="pre">receive</span></code> as combination of these partial functions.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">ProducerBehavior</span> <span class="o">{</span>
  <span class="k">this:</span> <span class="kt">Actor</span> <span class="o">=&gt;</span>

  <span class="k">val</span> <span class="n">producerBehavior</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">GiveMeThings</span> <span class="k">=&gt;</span>
      <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">Give</span><span class="o">(</span><span class="s">&quot;thing&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">ConsumerBehavior</span> <span class="o">{</span>
  <span class="k">this:</span> <span class="kt">Actor</span> <span class="kt">with</span> <span class="kt">ActorLogging</span> <span class="o">=&gt;</span>

  <span class="k">val</span> <span class="n">consumerBehavior</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ref</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=&gt;</span>
      <span class="n">ref</span> <span class="o">!</span> <span class="nc">GiveMeThings</span>

    <span class="k">case</span> <span class="nc">Give</span><span class="o">(</span><span class="n">thing</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Got a thing! It&#39;s {}&quot;</span><span class="o">,</span> <span class="n">thing</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Producer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ProducerBehavior</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">producerBehavior</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Consumer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="k">with</span> <span class="nc">ConsumerBehavior</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">consumerBehavior</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ProducerConsumer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span>
  <span class="k">with</span> <span class="nc">ProducerBehavior</span> <span class="k">with</span> <span class="nc">ConsumerBehavior</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">producerBehavior</span><span class="o">.</span><span class="n">orElse</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Unit</span><span class="o">](</span><span class="n">consumerBehavior</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// protocol</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">GiveMeThings</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Give</span><span class="o">(</span><span class="n">thing</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span>
</pre></div>
</div>
<p>Instead of inheritance the same pattern can be applied via composition - one would simply compose the receive method using partial functions from delegates.</p>
</div>
<div class="section" id="initialization-patterns">
<h2>Initialization patterns</h2>
<p>The rich lifecycle hooks of Actors provide a useful toolkit to implement various initialization patterns. During the
lifetime of an <code class="docutils literal"><span class="pre">ActorRef</span></code>, an actor can potentially go through several restarts, where the old instance is replaced by
a fresh one, invisibly to the outside observer who only sees the <code class="docutils literal"><span class="pre">ActorRef</span></code>.</p>
<p>One may think about the new instances as &quot;incarnations&quot;. Initialization might be necessary for every incarnation
of an actor, but sometimes one needs initialization to happen only at the birth of the first instance when the
<code class="docutils literal"><span class="pre">ActorRef</span></code> is created. The following sections provide patterns for different initialization needs.</p>
<div class="section" id="initialization-via-constructor">
<h3>Initialization via constructor</h3>
<p>Using the constructor for initialization has various benefits. First of all, it makes it possible to use <code class="docutils literal"><span class="pre">val</span></code> fields to store
any state that does not change during the life of the actor instance, making the implementation of the actor more robust.
The constructor is invoked for every incarnation of the actor, therefore the internals of the actor can always assume
that proper initialization happened. This is also the drawback of this approach, as there are cases when one would
like to avoid reinitializing internals on restart. For example, it is often useful to preserve child actors across
restarts. The following section provides a pattern for this case.</p>
</div>
<div class="section" id="initialization-via-prestart">
<h3>Initialization via preStart</h3>
<p>The method <code class="docutils literal"><span class="pre">preStart()</span></code> of an actor is only called once directly during the initialization of the first instance, that
is, at creation of its <code class="docutils literal"><span class="pre">ActorRef</span></code>. In the case of restarts, <code class="docutils literal"><span class="pre">preStart()</span></code> is called from <code class="docutils literal"><span class="pre">postRestart()</span></code>, therefore
if not overridden, <code class="docutils literal"><span class="pre">preStart()</span></code> is called on every incarnation. However, by overriding <code class="docutils literal"><span class="pre">postRestart()</span></code> one can disable
this behavior, and ensure that there is only one call to <code class="docutils literal"><span class="pre">preStart()</span></code>.</p>
<p>One useful usage of this pattern is to disable creation of new <code class="docutils literal"><span class="pre">ActorRefs</span></code> for children during restarts. This can be
achieved by overriding <code class="docutils literal"><span class="pre">preRestart()</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// Initialize children here</span>
<span class="o">}</span>

<span class="c1">// Overriding postRestart to disable the call to preStart()</span>
<span class="c1">// after restarts</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">postRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

<span class="c1">// The default implementation of preRestart() stops all the children</span>
<span class="c1">// of the actor. To opt-out from stopping the children, we</span>
<span class="c1">// have to override preRestart()</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">preRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// Keep the call to postStop(), but no stopping of children</span>
  <span class="n">postStop</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note, that the child actors are <em>still restarted</em>, but no new <code class="docutils literal"><span class="pre">ActorRef</span></code> is created. One can recursively apply
the same principles for the children, ensuring that their <code class="docutils literal"><span class="pre">preStart()</span></code> method is called only at the creation of their
refs.</p>
<p>For more information see <a class="reference internal" href="../general/supervision.html#supervision-restart"><span class="std std-ref">What Restarting Means</span></a>.</p>
</div>
<div class="section" id="initialization-via-message-passing">
<h3>Initialization via message passing</h3>
<p>There are cases when it is impossible to pass all the information needed for actor initialization in the constructor,
for example in the presence of circular dependencies. In this case the actor should listen for an initialization message,
and use <code class="docutils literal"><span class="pre">become()</span></code> or a finite state-machine state transition to encode the initialized and uninitialized states
of the actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">initializeMe</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;init&quot;</span> <span class="k">=&gt;</span>
    <span class="n">initializeMe</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;Up and running&quot;</span><span class="o">)</span>
    <span class="n">context</span><span class="o">.</span><span class="n">become</span><span class="o">(</span><span class="n">initialized</span><span class="o">,</span> <span class="n">discardOld</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

<span class="o">}</span>

<span class="k">def</span> <span class="n">initialized</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;U OK?&quot;</span> <span class="k">=&gt;</span> <span class="n">initializeMe</span> <span class="n">foreach</span> <span class="o">{</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="k">_</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If the actor may receive messages before it has been initialized, a useful tool can be the <code class="docutils literal"><span class="pre">Stash</span></code> to save messages
until the initialization finishes, and replaying them after the actor became initialized.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">This pattern should be used with care, and applied only when none of the patterns above are applicable. One of
the potential issues is that messages might be lost when sent to remote actors. Also, publishing an <code class="docutils literal"><span class="pre">ActorRef</span></code> in
an uninitialized state might lead to the condition that it receives a user message before the initialization has been
done.</p>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: 10月 15, 2016
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>